<!DOCTYPE html>
<html>
  <head>
  <meta charset='UTF-8'>
  <title>CoffeeScript API Documentation</title>
  <script src='../../javascript/application.js'></script>
  <script src='../../javascript/search.js'></script>
  <link rel='stylesheet' href='../../stylesheets/application.css' type='text/css'>
</head>
  <body>
    <div id='base' data-path='../../'></div>
<div id='header'>
  <div id='menu'>
    <a href='../../alphabetical_index.html' title='Index'>
      Index
    </a>
    &raquo;
    <span class='title'>node_modules\express\node_modules\proxy-addr\node_modules\ipaddr.js\test\ipaddr.test.coffee</span>
  </div>
</div>
    <div id='content'>
      <h1>
        File:
        ipaddr.test.coffee
      </h1>
      <table class='box'>
        <tr>
          <td>Defined in:</td>
          <td>node_modules\express\node_modules\proxy-addr\node_modules\ipaddr.js\test</td>
        </tr>
      </table>
      <h2>Variables Summary</h2>
      <dl class='constants'>
  <dt id='module.exports-variable'>
    module.exports
    =
  </dt>
  <dd>
    <pre><code class='coffeescript'>{
  &#39;should define main classes&#39;: function(test) {
    test.ok(ipaddr.IPv4 != null, &#39;defines IPv4 class&#39;);
    test.ok(ipaddr.IPv6 != null, &#39;defines IPv6 class&#39;);
    return test.done();
  },
  &#39;can construct IPv4 from octets&#39;: function(test) {
    test.doesNotThrow(function() {
      return new ipaddr.IPv4([192, 168, 1, 2]);
    });
    return test.done();
  },
  &#39;refuses to construct invalid IPv4&#39;: function(test) {
    test.throws(function() {
      return new ipaddr.IPv4([300, 1, 2, 3]);
    });
    test.throws(function() {
      return new ipaddr.IPv4([8, 8, 8]);
    });
    return test.done();
  },
  &#39;converts IPv4 to string correctly&#39;: function(test) {
    var addr;
    addr = new ipaddr.IPv4([192, 168, 1, 1]);
    test.equal(addr.toString(), &#39;192.168.1.1&#39;);
    return test.done();
  },
  &#39;returns correct kind for IPv4&#39;: function(test) {
    var addr;
    addr = new ipaddr.IPv4([1, 2, 3, 4]);
    test.equal(addr.kind(), &#39;ipv4&#39;);
    return test.done();
  },
  &#39;allows to access IPv4 octets&#39;: function(test) {
    var addr;
    addr = new ipaddr.IPv4([42, 0, 0, 0]);
    test.equal(addr.octets[0], 42);
    return test.done();
  },
  &#39;checks IPv4 address format&#39;: function(test) {
    test.equal(ipaddr.IPv4.isIPv4(&#39;192.168.007.0xa&#39;), true);
    test.equal(ipaddr.IPv4.isIPv4(&#39;1024.0.0.1&#39;), true);
    test.equal(ipaddr.IPv4.isIPv4(&#39;8.0xa.wtf.6&#39;), false);
    return test.done();
  },
  &#39;validates IPv4 addresses&#39;: function(test) {
    test.equal(ipaddr.IPv4.isValid(&#39;192.168.007.0xa&#39;), true);
    test.equal(ipaddr.IPv4.isValid(&#39;1024.0.0.1&#39;), false);
    test.equal(ipaddr.IPv4.isValid(&#39;8.0xa.wtf.6&#39;), false);
    return test.done();
  },
  &#39;parses IPv4 in several weird formats&#39;: function(test) {
    test.deepEqual(ipaddr.IPv4.parse(&#39;192.168.1.1&#39;).octets, [192, 168, 1, 1]);
    test.deepEqual(ipaddr.IPv4.parse(&#39;0xc0.168.1.1&#39;).octets, [192, 168, 1, 1]);
    test.deepEqual(ipaddr.IPv4.parse(&#39;192.0250.1.1&#39;).octets, [192, 168, 1, 1]);
    test.deepEqual(ipaddr.IPv4.parse(&#39;0xc0a80101&#39;).octets, [192, 168, 1, 1]);
    test.deepEqual(ipaddr.IPv4.parse(&#39;030052000401&#39;).octets, [192, 168, 1, 1]);
    test.deepEqual(ipaddr.IPv4.parse(&#39;3232235777&#39;).octets, [192, 168, 1, 1]);
    return test.done();
  },
  &#39;barfs at invalid IPv4&#39;: function(test) {
    test.throws(function() {
      return ipaddr.IPv4.parse(&#39;10.0.0.wtf&#39;);
    });
    return test.done();
  },
  &#39;matches IPv4 CIDR correctly&#39;: function(test) {
    var addr;
    addr = new ipaddr.IPv4([10, 5, 0, 1]);
    test.equal(addr.match(ipaddr.IPv4.parse(&#39;0.0.0.0&#39;), 0), true);
    test.equal(addr.match(ipaddr.IPv4.parse(&#39;11.0.0.0&#39;), 8), false);
    test.equal(addr.match(ipaddr.IPv4.parse(&#39;10.0.0.0&#39;), 8), true);
    test.equal(addr.match(ipaddr.IPv4.parse(&#39;10.0.0.1&#39;), 8), true);
    test.equal(addr.match(ipaddr.IPv4.parse(&#39;10.0.0.10&#39;), 8), true);
    test.equal(addr.match(ipaddr.IPv4.parse(&#39;10.5.5.0&#39;), 16), true);
    test.equal(addr.match(ipaddr.IPv4.parse(&#39;10.4.5.0&#39;), 16), false);
    test.equal(addr.match(ipaddr.IPv4.parse(&#39;10.4.5.0&#39;), 15), true);
    test.equal(addr.match(ipaddr.IPv4.parse(&#39;10.5.0.2&#39;), 32), false);
    test.equal(addr.match(addr, 32), true);
    return test.done();
  },
  &#39;detects reserved IPv4 networks&#39;: function(test) {
    test.equal(ipaddr.IPv4.parse(&#39;10.1.0.1&#39;).range(), &#39;private&#39;);
    test.equal(ipaddr.IPv4.parse(&#39;192.168.2.1&#39;).range(), &#39;private&#39;);
    test.equal(ipaddr.IPv4.parse(&#39;224.100.0.1&#39;).range(), &#39;multicast&#39;);
    test.equal(ipaddr.IPv4.parse(&#39;169.254.15.0&#39;).range(), &#39;linkLocal&#39;);
    test.equal(ipaddr.IPv4.parse(&#39;127.1.1.1&#39;).range(), &#39;loopback&#39;);
    test.equal(ipaddr.IPv4.parse(&#39;255.255.255.255&#39;).range(), &#39;broadcast&#39;);
    test.equal(ipaddr.IPv4.parse(&#39;240.1.2.3&#39;).range(), &#39;reserved&#39;);
    test.equal(ipaddr.IPv4.parse(&#39;8.8.8.8&#39;).range(), &#39;unicast&#39;);
    return test.done();
  },
  &#39;can construct IPv6 from parts&#39;: function(test) {
    test.doesNotThrow(function() {
      return new ipaddr.IPv6([0x2001, 0xdb8, 0xf53a, 0, 0, 0, 0, 1]);
    });
    return test.done();
  },
  &#39;refuses to construct invalid IPv6&#39;: function(test) {
    test.throws(function() {
      return new ipaddr.IPv6([0xfffff, 0, 0, 0, 0, 0, 0, 1]);
    });
    test.throws(function() {
      return new ipaddr.IPv6([0xfffff, 0, 0, 0, 0, 0, 1]);
    });
    return test.done();
  },
  &#39;converts IPv6 to string correctly&#39;: function(test) {
    var addr;
    addr = new ipaddr.IPv6([0x2001, 0xdb8, 0xf53a, 0, 0, 0, 0, 1]);
    test.equal(addr.toNormalizedString(), &#39;2001:db8:f53a:0:0:0:0:1&#39;);
    test.equal(addr.toString(), &#39;2001:db8:f53a::1&#39;);
    test.equal(new ipaddr.IPv6([0, 0, 0, 0, 0, 0, 0, 1]).toString(), &#39;::1&#39;);
    test.equal(new ipaddr.IPv6([0x2001, 0xdb8, 0, 0, 0, 0, 0, 0]).toString(), &#39;2001:db8::&#39;);
    return test.done();
  },
  &#39;returns correct kind for IPv6&#39;: function(test) {
    var addr;
    addr = new ipaddr.IPv6([0x2001, 0xdb8, 0xf53a, 0, 0, 0, 0, 1]);
    test.equal(addr.kind(), &#39;ipv6&#39;);
    return test.done();
  },
  &#39;allows to access IPv6 address parts&#39;: function(test) {
    var addr;
    addr = new ipaddr.IPv6([0x2001, 0xdb8, 0xf53a, 0, 0, 42, 0, 1]);
    test.equal(addr.parts[5], 42);
    return test.done();
  },
  &#39;checks IPv6 address format&#39;: function(test) {
    test.equal(ipaddr.IPv6.isIPv6(&#39;2001:db8:F53A::1&#39;), true);
    test.equal(ipaddr.IPv6.isIPv6(&#39;200001::1&#39;), true);
    test.equal(ipaddr.IPv6.isIPv6(&#39;::ffff:192.168.1.1&#39;), true);
    test.equal(ipaddr.IPv6.isIPv6(&#39;::ffff:300.168.1.1&#39;), true);
    test.equal(ipaddr.IPv6.isIPv6(&#39;::ffff:300.168.1.1:0&#39;), false);
    test.equal(ipaddr.IPv6.isIPv6(&#39;fe80::wtf&#39;), false);
    return test.done();
  },
  &#39;validates IPv6 addresses&#39;: function(test) {
    test.equal(ipaddr.IPv6.isValid(&#39;2001:db8:F53A::1&#39;), true);
    test.equal(ipaddr.IPv6.isValid(&#39;200001::1&#39;), false);
    test.equal(ipaddr.IPv6.isValid(&#39;::ffff:192.168.1.1&#39;), true);
    test.equal(ipaddr.IPv6.isValid(&#39;::ffff:300.168.1.1&#39;), false);
    test.equal(ipaddr.IPv6.isValid(&#39;::ffff:300.168.1.1:0&#39;), false);
    test.equal(ipaddr.IPv6.isValid(&#39;2001:db8::F53A::1&#39;), false);
    test.equal(ipaddr.IPv6.isValid(&#39;fe80::wtf&#39;), false);
    return test.done();
  },
  &#39;parses IPv6 in different formats&#39;: function(test) {
    test.deepEqual(ipaddr.IPv6.parse(&#39;2001:db8:F53A:0:0:0:0:1&#39;).parts, [0x2001, 0xdb8, 0xf53a, 0, 0, 0, 0, 1]);
    test.deepEqual(ipaddr.IPv6.parse(&#39;fe80::10&#39;).parts, [0xfe80, 0, 0, 0, 0, 0, 0, 0x10]);
    test.deepEqual(ipaddr.IPv6.parse(&#39;2001:db8:F53A::&#39;).parts, [0x2001, 0xdb8, 0xf53a, 0, 0, 0, 0, 0]);
    test.deepEqual(ipaddr.IPv6.parse(&#39;::1&#39;).parts, [0, 0, 0, 0, 0, 0, 0, 1]);
    test.deepEqual(ipaddr.IPv6.parse(&#39;::&#39;).parts, [0, 0, 0, 0, 0, 0, 0, 0]);
    return test.done();
  },
  &#39;barfs at invalid IPv6&#39;: function(test) {
    test.throws(function() {
      return ipaddr.IPv6.parse(&#39;fe80::0::1&#39;);
    });
    return test.done();
  },
  &#39;matches IPv6 CIDR correctly&#39;: function(test) {
    var addr;
    addr = ipaddr.IPv6.parse(&#39;2001:db8:f53a::1&#39;);
    test.equal(addr.match(ipaddr.IPv6.parse(&#39;::&#39;), 0), true);
    test.equal(addr.match(ipaddr.IPv6.parse(&#39;2001:db8:f53a::1:1&#39;), 64), true);
    test.equal(addr.match(ipaddr.IPv6.parse(&#39;2001:db8:f53b::1:1&#39;), 48), false);
    test.equal(addr.match(ipaddr.IPv6.parse(&#39;2001:db8:f531::1:1&#39;), 44), true);
    test.equal(addr.match(ipaddr.IPv6.parse(&#39;2001:db8:f500::1&#39;), 40), true);
    test.equal(addr.match(ipaddr.IPv6.parse(&#39;2001:db9:f500::1&#39;), 40), false);
    test.equal(addr.match(addr, 128), true);
    return test.done();
  },
  &#39;converts between IPv4-mapped IPv6 addresses and IPv4 addresses&#39;: function(test) {
    var addr, mapped;
    addr = ipaddr.IPv4.parse(&#39;77.88.21.11&#39;);
    mapped = addr.toIPv4MappedAddress();
    test.deepEqual(mapped.parts, [0, 0, 0, 0, 0, 0xffff, 0x4d58, 0x150b]);
    test.deepEqual(mapped.toIPv4Address().octets, addr.octets);
    return test.done();
  },
  &#39;refuses to convert non-IPv4-mapped IPv6 address to IPv4 address&#39;: function(test) {
    test.throws(function() {
      return ipaddr.IPv6.parse(&#39;2001:db8::1&#39;).toIPv4Address();
    });
    return test.done();
  },
  &#39;detects reserved IPv6 networks&#39;: function(test) {
    test.equal(ipaddr.IPv6.parse(&#39;::&#39;).range(), &#39;unspecified&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;fe80::1234:5678:abcd:0123&#39;).range(), &#39;linkLocal&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;ff00::1234&#39;).range(), &#39;multicast&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;::1&#39;).range(), &#39;loopback&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;fc00::&#39;).range(), &#39;uniqueLocal&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;::ffff:192.168.1.10&#39;).range(), &#39;ipv4Mapped&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;::ffff:0:192.168.1.10&#39;).range(), &#39;rfc6145&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;64:ff9b::1234&#39;).range(), &#39;rfc6052&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;2002:1f63:45e8::1&#39;).range(), &#39;6to4&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;2001::4242&#39;).range(), &#39;teredo&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;2001:db8::3210&#39;).range(), &#39;reserved&#39;);
    test.equal(ipaddr.IPv6.parse(&#39;2001:470:8:66::1&#39;).range(), &#39;unicast&#39;);
    return test.done();
  },
  &#39;is able to determine IP address type&#39;: function(test) {
    test.equal(ipaddr.parse(&#39;8.8.8.8&#39;).kind(), &#39;ipv4&#39;);
    test.equal(ipaddr.parse(&#39;2001:db8:3312::1&#39;).kind(), &#39;ipv6&#39;);
    return test.done();
  },
  &#39;throws an error if tried to parse an invalid address&#39;: function(test) {
    test.throws(function() {
      return ipaddr.parse(&#39;::some.nonsense&#39;);
    });
    return test.done();
  },
  &#39;correctly processes IPv4-mapped addresses&#39;: function(test) {
    test.equal(ipaddr.process(&#39;8.8.8.8&#39;).kind(), &#39;ipv4&#39;);
    test.equal(ipaddr.process(&#39;2001:db8:3312::1&#39;).kind(), &#39;ipv6&#39;);
    test.equal(ipaddr.process(&#39;::ffff:192.168.1.1&#39;).kind(), &#39;ipv4&#39;);
    return test.done();
  },
  &#39;correctly converts IPv6 and IPv4 addresses to byte arrays&#39;: function(test) {
    test.deepEqual(ipaddr.parse(&#39;1.2.3.4&#39;).toByteArray(), [0x1, 0x2, 0x3, 0x4]);
    test.deepEqual(ipaddr.parse(&#39;2a00:1450:8007::68&#39;).toByteArray(), [42, 0x00, 0x14, 0x50, 0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68]);
    return test.done();
  },
  &#39;correctly parses 1 as an IPv4 address&#39;: function(test) {
    test.equal(ipaddr.IPv6.isValid(&#39;1&#39;), false);
    test.equal(ipaddr.IPv4.isValid(&#39;1&#39;), true);
    test.deepEqual(new ipaddr.IPv4([0, 0, 0, 1]), ipaddr.parse(&#39;1&#39;));
    return test.done();
  },
  &#39;does not consider a very large or very small number a valid IP address&#39;: function(test) {
    test.equal(ipaddr.isValid(&#39;4999999999&#39;), false);
    test.equal(ipaddr.isValid(&#39;-1&#39;), false);
    return test.done();
  }
}</code></pre>
    
  </dd>
</dl>
    </div>
    <div id='footer'>
  January 21, 15 15:09:25 by
  <a href='https://github.com/coffeedoc/codo' title='CoffeeScript API documentation generator'>
    Codo
  </a>
  2.0.9
  &#10034;
  Press H to see the keyboard shortcuts
  &#10034;
  <a href='http://twitter.com/netzpirat' target='_parent'>@netzpirat</a>
  &#10034;
  <a href='http://twitter.com/_inossidabile' target='_parent'>@_inossidabile</a>
</div>
<iframe id='search_frame'></iframe>
<div id='fuzzySearch'>
  <input type='text'>
  <ol></ol>
</div>
<div id='help'>
  <p>
    Quickly fuzzy find classes, mixins, methods, file:
  </p>
  <ul>
    <li>
      <span>T</span>
      Open fuzzy finder dialog
    </li>
  </ul>
  <p>
    Control the navigation frame:
  </p>
  <ul>
    <li>
      <span>L</span>
      Toggle list view
    </li>
    <li>
      <span>C</span>
      Show class list
    </li>
    <li>
      <span>I</span>
      Show mixin list
    </li>
    <li>
      <span>F</span>
      Show file list
    </li>
    <li>
      <span>M</span>
      Show method list
    </li>
    <li>
      <span>E</span>
      Show extras list
    </li>
  </ul>
  <p>
    You can focus and blur the search input:
  </p>
  <ul>
    <li>
      <span>S</span>
      Focus search input
    </li>
    <li>
      <span>Esc</span>
      Blur search input
    </li>
  </ul>
</div>
  </body>
</html>