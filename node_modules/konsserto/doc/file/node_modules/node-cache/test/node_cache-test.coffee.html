<!DOCTYPE html>
<html>
  <head>
  <meta charset='UTF-8'>
  <title>CoffeeScript API Documentation</title>
  <script src='../../javascript/application.js'></script>
  <script src='../../javascript/search.js'></script>
  <link rel='stylesheet' href='../../stylesheets/application.css' type='text/css'>
</head>
  <body>
    <div id='base' data-path='../../'></div>
<div id='header'>
  <div id='menu'>
    <a href='../../alphabetical_index.html' title='Index'>
      Index
    </a>
    &raquo;
    <span class='title'>node_modules\node-cache\test\node_cache-test.coffee</span>
  </div>
</div>
    <div id='content'>
      <h1>
        File:
        node_cache-test.coffee
      </h1>
      <table class='box'>
        <tr>
          <td>Defined in:</td>
          <td>node_modules\node-cache\test</td>
        </tr>
      </table>
      <h2>Variables Summary</h2>
      <dl class='constants'>
  <dt id='vs-variable'>
    vs
    =
  </dt>
  <dd>
    <pre><code class='coffeescript'>[]</code></pre>
    
  </dd>
  <dt id='ks-variable'>
    ks
    =
  </dt>
  <dd>
    <pre><code class='coffeescript'>[]</code></pre>
    
  </dd>
  <dt id='module.exports-variable'>
    module.exports
    =
  </dt>
  <dd>
    <pre><code class='coffeescript'>{
  &quot;general&quot;: function(beforeExit, assert) {
    var key, n, start, value, value2;
    console.log(&quot;START GENERAL TEST&quot;);
    n = 0;
    start = _.clone(localCache.getStats());
    value = randomString(100);
    value2 = randomString(100);
    key = randomString(10);
    localCache.once(&quot;del&quot;, function(_key) {
      assert.equal(_key, key);
    });
    localCache.set(key, value, 0, function(err, res) {
      assert.isNull(err, err);
      n++;
      assert.equal(1, localCache.getStats().keys - start.keys);
      localCache.get(key, function(err, res) {
        var pred;
        n++;

        &#47;*
        generate a predicted value
         *&#47;
        pred = {};
        pred[key] = value;
        return assert.eql(pred, res);
      });
      localCache.get(&quot;xxx&quot;, function(err, res) {
        n++;
        assert.isNull(err, err);
        return assert.eql({}, res);
      });
      localCache.del(&quot;xxx&quot;, function(err, res) {
        n++;
        assert.isNull(err, err);
        return assert.equal(0, res);
      });
      localCache.set(key, value2, 0, function(err, res) {
        n++;
        assert.isNull(err, err);
        assert.ok(res, err);
        return localCache.get(key, function(err, res) {
          var pred;
          n++;

          &#47;*
          generate a predicted value
           *&#47;
          pred = {};
          pred[key] = value2;
          assert.eql(pred, res);
          return assert.equal(1, localCache.getStats().keys - start.keys);
        });
      });
      return localCache.del(key, function(err, res) {
        localCache.removeAllListeners(&quot;del&quot;);
        n++;
        assert.isNull(err, err);
        assert.equal(1, res);
        assert.equal(0, localCache.getStats().keys - start.keys);
        return localCache.get(key, function(err, res) {
          n++;
          assert.isNull(err, err);
          return assert.eql({}, res);
        });
      });
    });
    return beforeExit(function() {
      return assert.equal(8, n, &quot;not exited&quot;);
    });
  },
  &quot;flush&quot;: function(beforeExit, assert) {
    var count, i, key, ks, n, startKeys, val, _i, _j, _len;
    console.log(&quot;START FLUSH TEST&quot;);
    n = 0;
    count = 100;
    startKeys = localCache.getStats().keys;

    &#47;*
    set `count` values
     *&#47;
    ks = [];
    val = randomString(20);
    for (i = _i = 1; 1 &lt;= count ? _i &lt;= count : _i &gt;= count; i = 1 &lt;= count ? ++_i : --_i) {
      key = randomString(7);
      ks.push(key);
    }
    for (_j = 0, _len = ks.length; _j &lt; _len; _j++) {
      key = ks[_j];
      localCache.set(key, val, 0, function(err, res) {
        n++;
        assert.isNull(err, err);
      });
    }
    assert.equal(localCache.getStats().keys, startKeys + count);
    localCache.flushAll(false);
    assert.equal(localCache.getStats().keys, 0);
    assert.eql(localCache.data, {});
    return beforeExit(function() {
      return assert.equal(n, count + 0);
    });
  },
  &quot;many&quot;: function(beforeExit, assert) {
    var count, i, key, ks, n, time, val, _i, _j, _k, _len, _len1;
    n = 0;
    count = 100000;
    console.log(&quot;START MANY TEST&#47;BENCHMARK.\nSet, Get and check &quot; + count + &quot; elements&quot;);
    val = randomString(20);
    ks = [];
    for (i = _i = 1; 1 &lt;= count ? _i &lt;= count : _i &gt;= count; i = 1 &lt;= count ? ++_i : --_i) {
      key = randomString(7);
      ks.push(key);
    }
    time = new Date().getTime();
    for (_j = 0, _len = ks.length; _j &lt; _len; _j++) {
      key = ks[_j];
      localCache.set(key, val, 0, function(err, res) {
        assert.isNull(err, err);
      });
    }
    console.log(&quot;TIME-SET:&quot;, new Date().getTime() - time);
    time = new Date().getTime();
    for (_k = 0, _len1 = ks.length; _k &lt; _len1; _k++) {
      key = ks[_k];
      localCache.get(key, function(err, res) {
        var pred;
        n++;
        pred = {};
        pred[key] = val;
        return assert.eql(pred, res);
      });
    }
    console.log(&quot;TIME-GET:&quot;, new Date().getTime() - time);
    console.log(&quot;MANY STATS:&quot;, localCache.getStats());
    return beforeExit(function() {
      return assert.equal(n, count);
    });
  },
  &quot;delete&quot;: function(beforeExit, assert) {
    var count, i, n, ri, startKeys, _i, _j;
    console.log(&quot;START DELETE TEST&quot;);
    n = 0;
    count = 10000;
    startKeys = localCache.getStats().keys;
    for (i = _i = 1; 1 &lt;= count ? _i &lt;= count : _i &gt;= count; i = 1 &lt;= count ? ++_i : --_i) {
      ri = Math.floor(Math.random() * vs.length);
      localCache.del(ks[i], function(err, count) {
        n++;
        assert.isNull(err, err);
        return assert.equal(1, count);
      });
    }
    for (i = _j = 1; 1 &lt;= count ? _j &lt;= count : _j &gt;= count; i = 1 &lt;= count ? ++_j : --_j) {
      ri = Math.floor(Math.random() * vs.length);
      localCache.del(ks[i], function(err, count) {
        n++;
        assert.equal(0, count);
        return assert.isNull(err, err);
      });
    }
    assert.equal(localCache.getStats().keys, startKeys - count);
    return beforeExit(function() {
      return assert.equal(n, count * 2);
    });
  },
  &quot;stats&quot;: function(beforeExit, assert) {
    var count, end, i, key, keys, n, start, val, vals, _i, _j, _k, _ref;
    console.log(&quot;START STATS TEST&quot;);
    n = 0;
    start = _.clone(localCache.getStats());
    count = 5;
    keys = [];
    vals = [];
    for (i = _i = 1, _ref = count * 2; 1 &lt;= _ref ? _i &lt;= _ref : _i &gt;= _ref; i = 1 &lt;= _ref ? ++_i : --_i) {
      key = randomString(7);
      val = randomString(50);
      keys.push(key);
      vals.push(val);
      localCache.set(key, val, 0, function(err, success) {
        n++;
        assert.isNull(err, err);
        return assert.ok(success);
      });
    }
    for (i = _j = 1; 1 &lt;= count ? _j &lt;= count : _j &gt;= count; i = 1 &lt;= count ? ++_j : --_j) {
      localCache.get(keys[i], function(err, res) {
        var pred;
        n++;
        pred = {};
        pred[keys[i]] = vals[i];
        assert.eql(pred, res);
        return assert.isNull(err, err);
      });
      localCache.del(keys[i], function(err, success) {
        n++;
        assert.isNull(err, err);
        return assert.ok(success);
      });
    }
    for (i = _k = 1; 1 &lt;= count ? _k &lt;= count : _k &gt;= count; i = 1 &lt;= count ? ++_k : --_k) {
      localCache.get(&quot;xxxx&quot;, function(err, res) {
        ++n;
        assert.isNull(err, err);
        return assert.eql({}, res);
      });
    }
    end = localCache.getStats();
    assert.equal(end.hits - start.hits, 5, &quot;hits wrong&quot;);
    assert.equal(end.misses - start.misses, 5, &quot;misses wrong&quot;);
    assert.equal(end.keys - start.keys, 5, &quot;hits wrong&quot;);
    assert.equal(end.ksize - start.ksize, 5 * 7, &quot;hits wrong&quot;);
    assert.equal(end.vsize - start.vsize, 5 * 50, &quot;hits wrong&quot;);
    return beforeExit(function() {
      return assert.equal(n, count * 5);
    });
  },
  &quot;multi&quot;: function(beforeExit, assert) {
    var count, getKeys, i, key, ks, n, pred, startKeys, val, _i, _j, _k, _len, _len1;
    console.log(&quot;START MULTI TEST&quot;);
    n = 0;
    count = 100;
    startKeys = localCache.getStats().keys;

    &#47;*
    set `count` values
     *&#47;
    ks = [];
    val = randomString(20);
    for (i = _i = 1; 1 &lt;= count ? _i &lt;= count : _i &gt;= count; i = 1 &lt;= count ? ++_i : --_i) {
      key = randomString(7);
      ks.push(key);
    }
    for (_j = 0, _len = ks.length; _j &lt; _len; _j++) {
      key = ks[_j];
      localCache.set(key, val, 0, function(err, res) {
        n++;
        assert.isNull(err, err);
      });
    }

    &#47;*
    generate a sub list of keys
     *&#47;
    getKeys = ks.splice(50, 5);

    &#47;*
    generate prediction
     *&#47;
    pred = {};
    for (_k = 0, _len1 = getKeys.length; _k &lt; _len1; _k++) {
      key = getKeys[_k];
      pred[key] = val;
    }
    localCache.get(getKeys, function(err, res) {
      n++;
      assert.isNull(err, err);
      return assert.eql(pred, res);
    });
    localCache.del(getKeys, function(err, res) {
      n++;
      assert.isNull(err, err);
      return assert.equal(getKeys.length, res);
    });
    localCache.get(getKeys, function(err, res) {
      n++;
      assert.isNull(err, err);
      return assert.eql({}, res);
    });
    return beforeExit(function() {
      return assert.equal(n, count + 3);
    });
  },
  &quot;ttl&quot;: function(beforeExit, assert) {
    var key, key2, key3, key4, key5, n, val;
    console.log(&quot;START TTL TEST&quot;);
    val = randomString(20);
    key = randomString(7);
    key2 = randomString(7);
    key3 = randomString(7);
    key4 = randomString(7);
    key5 = randomString(7);
    n = 0;
    localCache.set(key, val, 0.5, function(err, res) {
      assert.isNull(err, err);
      assert.ok(res);
      return localCache.get(key, function(err, res) {
        var pred;
        assert.isNull(err, err);
        pred = {};
        pred[key] = val;
        return assert.eql(pred, res);
      });
    });
    localCache.set(key2, val, 0.4, function(err, res) {
      assert.isNull(err, err);
      assert.ok(res);
      return localCache.get(key2, function(err, res) {
        var pred;
        assert.isNull(err, err);
        pred = {};
        pred[key2] = val;
        return assert.eql(pred, res);
      });
    });
    setTimeout(function() {
      ++n;
      return localCache.get(key, function(err, res) {
        var pred;
        assert.isNull(err, err);
        pred = {};
        pred[key] = val;
        return assert.eql(pred, res);
      });
    }, 400);
    setTimeout(function() {
      ++n;
      return localCache.get(key, function(err, res) {
        assert.isNull(err, err);
        return assert.eql({}, res);
      });
    }, 600);
    setTimeout(function() {
      ++n;
      return localCache.get(key2, function(err, res) {
        var pred;
        assert.isNull(err, err);
        pred = {};
        pred[key2] = val;
        assert.eql(pred, res);
        return assert.eql(pred, res);
      });
    }, 300);
    setTimeout(function() {
      var startKeys, _testExpired, _testSet;
      startKeys = localCache.getStats().keys;
      key = &quot;autotest&quot;;
      _testExpired = (function(_this) {
        return function(_key, _val) {
          assert.equal(_key, key);
          assert.equal(_val, val);
        };
      })(this);
      _testSet = (function(_this) {
        return function(_key) {
          assert.equal(_key, key);
        };
      })(this);
      localCache.once(&quot;set&quot;, _testSet);
      return localCache.set(key, val, 0.5, function(err, res) {
        assert.isNull(err, err);
        assert.ok(res);
        assert.equal(startKeys + 1, localCache.getStats().keys);
        return localCache.get(key, function(err, res) {
          var pred;
          pred = {};
          pred[key] = val;
          assert.eql(pred, res);
          localCache.on(&quot;expired&quot;, _testExpired);
          return setTimeout(function() {
            localCache._checkData(false);
            assert.isUndefined(localCache.data[key]);
            localCache.removeAllListeners(&quot;set&quot;);
            return localCache.removeAllListeners(&quot;expired&quot;);
          }, 700);
        });
      });
    }, 1000);
    localCache.set(key3, val, 100, function(err, res) {
      assert.isNull(err, err);
      assert.ok(res);
      return localCache.get(key3, function(err, res) {
        var pred;
        assert.isNull(err, err);
        pred = {};
        pred[key3] = val;
        assert.eql(pred, res);
        localCache.ttl(key3 + &quot;false&quot;, 0.3, function(err, setted) {
          assert.isNull(err, err);
          return assert.equal(false, setted);
        });
        localCache.ttl(key3, 0.3, function(err, setted) {
          assert.isNull(err, err);
          return assert.ok(setted);
        });
        localCache.get(key3, function(err, res) {
          pred = {};
          pred[key3] = val;
          return assert.eql(pred, res);
        });
        return setTimeout(function() {
          localCache._checkData(false);
          return assert.isUndefined(localCache.data[key3]);
        }, 500);
      });
    });
    localCache.set(key4, val, 100, function(err, res) {
      assert.isNull(err, err);
      assert.ok(res);
      return localCache.get(key4, function(err, res) {
        var pred;
        assert.isNull(err, err);
        pred = {};
        pred[key4] = val;
        assert.eql(pred, res);
        localCache.ttl(key4 + &quot;false&quot;, function(err, setted) {
          assert.isNull(err, err);
          return assert.equal(false, setted);
        });
        return localCache.ttl(key4, function(err, setted) {
          assert.isNull(err, err);
          assert.ok(setted);
          return assert.isUndefined(localCache.data[key4]);
        });
      });
    });
    return localCacheTTL.set(key5, val, 100, function(err, res) {
      assert.isNull(err, err);
      assert.ok(res);
      return localCacheTTL.get(key5, function(err, res) {
        var pred;
        assert.isNull(err, err);
        pred = {};
        pred[key5] = val;
        assert.eql(pred, res);
        localCacheTTL.ttl(key5 + &quot;false&quot;, function(err, setted) {
          assert.isNull(err, err);
          return assert.equal(false, setted);
        });
        localCacheTTL.ttl(key5, function(err, setted) {
          assert.isNull(err, err);
          return assert.ok(setted);
        });
        localCacheTTL.get(key5, function(err, res) {
          pred = {};
          pred[key5] = val;
          return assert.eql(pred, res);
        });
        return setTimeout(function() {
          localCacheTTL._checkData(false);
          return assert.isUndefined(localCacheTTL.data[key5]);
        }, 500);
      });
    });
  }
}</code></pre>
    <div class='docstring'>
  <p>define tests</p>
</div>
<div class='tags'>
</div>
  </dd>
</dl>
      <h2>Method Summary</h2>
      <ul class='summary'>
  <li>
    <span class='signature'>
      <a href='#randomString-'>
        ~
(void)
<b>randomString</b><span>(length, withnumbers = true)</span>
      </a>
    </span>
    <span class='desc'>
      test helper 
    </span>
  </li>
</ul>
      <h2>Method Details</h2>
      <div class='methods'>
  <div class='method_details'>
    <p class='signature' id='randomString-'>
      ~
(void)
<b>randomString</b><span>(length, withnumbers = true)</span>
      <br>
    </p>
    <div class='docstring'>
  <p>test helper</p>
</div>
<div class='tags'>
</div>
  </div>
</div>
    </div>
    <div id='footer'>
  January 21, 15 11:57:32 by
  <a href='https://github.com/coffeedoc/codo' title='CoffeeScript API documentation generator'>
    Codo
  </a>
  2.0.9
  &#10034;
  Press H to see the keyboard shortcuts
  &#10034;
  <a href='http://twitter.com/netzpirat' target='_parent'>@netzpirat</a>
  &#10034;
  <a href='http://twitter.com/_inossidabile' target='_parent'>@_inossidabile</a>
</div>
<iframe id='search_frame'></iframe>
<div id='fuzzySearch'>
  <input type='text'>
  <ol></ol>
</div>
<div id='help'>
  <p>
    Quickly fuzzy find classes, mixins, methods, file:
  </p>
  <ul>
    <li>
      <span>T</span>
      Open fuzzy finder dialog
    </li>
  </ul>
  <p>
    Control the navigation frame:
  </p>
  <ul>
    <li>
      <span>L</span>
      Toggle list view
    </li>
    <li>
      <span>C</span>
      Show class list
    </li>
    <li>
      <span>I</span>
      Show mixin list
    </li>
    <li>
      <span>F</span>
      Show file list
    </li>
    <li>
      <span>M</span>
      Show method list
    </li>
    <li>
      <span>E</span>
      Show extras list
    </li>
  </ul>
  <p>
    You can focus and blur the search input:
  </p>
  <ul>
    <li>
      <span>S</span>
      Focus search input
    </li>
    <li>
      <span>Esc</span>
      Blur search input
    </li>
  </ul>
</div>
  </body>
</html>