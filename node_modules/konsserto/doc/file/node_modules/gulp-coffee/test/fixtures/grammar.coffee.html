<!DOCTYPE html>
<html>
  <head>
  <meta charset='UTF-8'>
  <title>CoffeeScript API Documentation</title>
  <script src='../../javascript/application.js'></script>
  <script src='../../javascript/search.js'></script>
  <link rel='stylesheet' href='../../stylesheets/application.css' type='text/css'>
</head>
  <body>
    <div id='base' data-path='../../'></div>
<div id='header'>
  <div id='menu'>
    <a href='../../alphabetical_index.html' title='Index'>
      Index
    </a>
    &raquo;
    <span class='title'>node_modules\gulp-coffee\test\fixtures\grammar.coffee</span>
  </div>
</div>
    <div id='content'>
      <h1>
        File:
        grammar.coffee
      </h1>
      <table class='box'>
        <tr>
          <td>Defined in:</td>
          <td>node_modules\gulp-coffee\test\fixtures</td>
        </tr>
      </table>
      <h2>Variables Summary</h2>
      <dl class='constants'>
  <dt id='unwrap-variable'>
    unwrap
    =
  </dt>
  <dd>
    <pre><code class='coffeescript'>&#47;^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}&#47;</code></pre>
    <div class='docstring'>
  <p>Since we&#39;re going to be wrapped in a function by Jison in any case, if our
action immediately returns a value, we can optimize by removing the function
wrapper and just returning the value directly.</p>
</div>
<div class='tags'>
</div>
  </dd>
  <dt id='grammar-variable'>
    grammar
    =
  </dt>
  <dd>
    <pre><code class='coffeescript'>{

  &#47;*
  The **Root** is the top-level node in the syntax tree. Since we parse bottom-up,
  all parsing must end here.
   *&#47;
  Root: [
    o(&#39;&#39;, function() {
      return new Block;
    }), o(&#39;Body&#39;)
  ],

  &#47;*
  Any list of statements and expressions, separated by line breaks or semicolons.
   *&#47;
  Body: [
    o(&#39;Line&#39;, function() {
      return Block.wrap([$1]);
    }), o(&#39;Body TERMINATOR Line&#39;, function() {
      return $1.push($3);
    }), o(&#39;Body TERMINATOR&#39;)
  ],

  &#47;*
  Block and statements, which make up a line in a body.
   *&#47;
  Line: [o(&#39;Expression&#39;), o(&#39;Statement&#39;)],

  &#47;*
  Pure statements which cannot be expressions.
   *&#47;
  Statement: [
    o(&#39;Return&#39;), o(&#39;Comment&#39;), o(&#39;STATEMENT&#39;, function() {
      return new Literal($1);
    })
  ],

  &#47;*
  All the different types of expressions in our language. The basic unit of
  CoffeeScript is the **Expression** -- everything that can be an expression
  is one. Blocks serve as the building blocks of many other rules, making
  them somewhat circular.
   *&#47;
  Expression: [o(&#39;Value&#39;), o(&#39;Invocation&#39;), o(&#39;Code&#39;), o(&#39;Operation&#39;), o(&#39;Assign&#39;), o(&#39;If&#39;), o(&#39;Try&#39;), o(&#39;While&#39;), o(&#39;For&#39;), o(&#39;Switch&#39;), o(&#39;Class&#39;), o(&#39;Throw&#39;)],

  &#47;*
  An indented block of expressions. Note that the [Rewriter](rewriter.html)
  will convert some postfix forms into blocks for us, by adjusting the
  token stream.
   *&#47;
  Block: [
    o(&#39;INDENT OUTDENT&#39;, function() {
      return new Block;
    }), o(&#39;INDENT Body OUTDENT&#39;, function() {
      return $2;
    })
  ],

  &#47;*
  A literal identifier, a variable name or property.
   *&#47;
  Identifier: [
    o(&#39;IDENTIFIER&#39;, function() {
      return new Literal($1);
    })
  ],

  &#47;*
  Alphanumerics are separated from the other **Literal** matchers because
  they can also serve as keys in object literals.
   *&#47;
  AlphaNumeric: [
    o(&#39;NUMBER&#39;, function() {
      return new Literal($1);
    }), o(&#39;STRING&#39;, function() {
      return new Literal($1);
    })
  ],

  &#47;*
  All of our immediate values. Generally these can be passed straight
  through and printed to JavaScript.
   *&#47;
  Literal: [
    o(&#39;AlphaNumeric&#39;), o(&#39;JS&#39;, function() {
      return new Literal($1);
    }), o(&#39;REGEX&#39;, function() {
      return new Literal($1);
    }), o(&#39;DEBUGGER&#39;, function() {
      return new Literal($1);
    }), o(&#39;UNDEFINED&#39;, function() {
      return new Undefined;
    }), o(&#39;NULL&#39;, function() {
      return new Null;
    }), o(&#39;BOOL&#39;, function() {
      return new Bool($1);
    })
  ],

  &#47;*
  Assignment of a variable, property, or index to a value.
   *&#47;
  Assign: [
    o(&#39;Assignable = Expression&#39;, function() {
      return new Assign($1, $3);
    }), o(&#39;Assignable = TERMINATOR Expression&#39;, function() {
      return new Assign($1, $4);
    }), o(&#39;Assignable = INDENT Expression OUTDENT&#39;, function() {
      return new Assign($1, $4);
    })
  ],

  &#47;*
  Assignment when it happens within an object literal. The difference from
  the ordinary **Assign** is that these allow numbers and strings as keys.
   *&#47;
  AssignObj: [
    o(&#39;ObjAssignable&#39;, function() {
      return new Value($1);
    }), o(&#39;ObjAssignable : Expression&#39;, function() {
      return new Assign(LOC(1)(new Value($1)), $3, &#39;object&#39;);
    }), o(&#39;ObjAssignable : INDENT Expression OUTDENT&#39;, function() {
      return new Assign(LOC(1)(new Value($1)), $4, &#39;object&#39;);
    }), o(&#39;Comment&#39;)
  ],
  ObjAssignable: [o(&#39;Identifier&#39;), o(&#39;AlphaNumeric&#39;), o(&#39;ThisProperty&#39;)],

  &#47;*
  A return statement from a function body.
   *&#47;
  Return: [
    o(&#39;RETURN Expression&#39;, function() {
      return new Return($2);
    }), o(&#39;RETURN&#39;, function() {
      return new Return;
    })
  ],

  &#47;*
  A block comment.
   *&#47;
  Comment: [
    o(&#39;HERECOMMENT&#39;, function() {
      return new Comment($1);
    })
  ],

  &#47;*
  The **Code** node is the function literal. It&#39;s defined by an indented block
  of **Block** preceded by a function arrow, with an optional parameter
  list.
   *&#47;
  Code: [
    o(&#39;PARAM_START ParamList PARAM_END FuncGlyph Block&#39;, function() {
      return new Code($2, $5, $4);
    }), o(&#39;FuncGlyph Block&#39;, function() {
      return new Code([], $2, $1);
    })
  ],

  &#47;*
  CoffeeScript has two different symbols for functions. `-&gt;` is for ordinary
  functions, and `=&gt;` is for functions bound to the current value of *this*.
   *&#47;
  FuncGlyph: [
    o(&#39;-&gt;&#39;, function() {
      return &#39;func&#39;;
    }), o(&#39;=&gt;&#39;, function() {
      return &#39;boundfunc&#39;;
    })
  ],

  &#47;*
  An optional, trailing comma.
   *&#47;
  OptComma: [o(&#39;&#39;), o(&#39;,&#39;)],

  &#47;*
  The list of parameters that a function accepts can be of any length.
   *&#47;
  ParamList: [
    o(&#39;&#39;, function() {
      return [];
    }), o(&#39;Param&#39;, function() {
      return [$1];
    }), o(&#39;ParamList , Param&#39;, function() {
      return $1.concat($3);
    }), o(&#39;ParamList OptComma TERMINATOR Param&#39;, function() {
      return $1.concat($4);
    }), o(&#39;ParamList OptComma INDENT ParamList OptComma OUTDENT&#39;, function() {
      return $1.concat($4);
    })
  ],

  &#47;*
  A single parameter in a function definition can be ordinary, or a splat
  that hoovers up the remaining arguments.
   *&#47;
  Param: [
    o(&#39;ParamVar&#39;, function() {
      return new Param($1);
    }), o(&#39;ParamVar ...&#39;, function() {
      return new Param($1, null, true);
    }), o(&#39;ParamVar = Expression&#39;, function() {
      return new Param($1, $3);
    })
  ],

  &#47;*
  Function Parameters
   *&#47;
  ParamVar: [o(&#39;Identifier&#39;), o(&#39;ThisProperty&#39;), o(&#39;Array&#39;), o(&#39;Object&#39;)],

  &#47;*
  A splat that occurs outside of a parameter list.
   *&#47;
  Splat: [
    o(&#39;Expression ...&#39;, function() {
      return new Splat($1);
    })
  ],

  &#47;*
  Variables and properties that can be assigned to.
   *&#47;
  SimpleAssignable: [
    o(&#39;Identifier&#39;, function() {
      return new Value($1);
    }), o(&#39;Value Accessor&#39;, function() {
      return $1.add($2);
    }), o(&#39;Invocation Accessor&#39;, function() {
      return new Value($1, [].concat($2));
    }), o(&#39;ThisProperty&#39;)
  ],

  &#47;*
  Everything that can be assigned to.
   *&#47;
  Assignable: [
    o(&#39;SimpleAssignable&#39;), o(&#39;Array&#39;, function() {
      return new Value($1);
    }), o(&#39;Object&#39;, function() {
      return new Value($1);
    })
  ],

  &#47;*
  The types of things that can be treated as values -- assigned to, invoked
  as functions, indexed into, named as a class, etc.
   *&#47;
  Value: [
    o(&#39;Assignable&#39;), o(&#39;Literal&#39;, function() {
      return new Value($1);
    }), o(&#39;Parenthetical&#39;, function() {
      return new Value($1);
    }), o(&#39;Range&#39;, function() {
      return new Value($1);
    }), o(&#39;This&#39;)
  ],

  &#47;*
  The general group of accessors into an object, by property, by prototype
  or by array index or slice.
   *&#47;
  Accessor: [
    o(&#39;.  Identifier&#39;, function() {
      return new Access($2);
    }), o(&#39;?. Identifier&#39;, function() {
      return new Access($2, &#39;soak&#39;);
    }), o(&#39;:: Identifier&#39;, function() {
      return [LOC(1)(new Access(new Literal(&#39;prototype&#39;))), LOC(2)(new Access($2))];
    }), o(&#39;?:: Identifier&#39;, function() {
      return [LOC(1)(new Access(new Literal(&#39;prototype&#39;), &#39;soak&#39;)), LOC(2)(new Access($2))];
    }), o(&#39;::&#39;, function() {
      return new Access(new Literal(&#39;prototype&#39;));
    }), o(&#39;Index&#39;)
  ],

  &#47;*
  Indexing into an object or array using bracket notation.
   *&#47;
  Index: [
    o(&#39;INDEX_START IndexValue INDEX_END&#39;, function() {
      return $2;
    }), o(&#39;INDEX_SOAK  Index&#39;, function() {
      return extend($2, {
        soak: true
      });
    })
  ],
  IndexValue: [
    o(&#39;Expression&#39;, function() {
      return new Index($1);
    }), o(&#39;Slice&#39;, function() {
      return new Slice($1);
    })
  ],

  &#47;*
  In CoffeeScript, an object literal is simply a list of assignments.
   *&#47;
  Object: [
    o(&#39;{ AssignList OptComma }&#39;, function() {
      return new Obj($2, $1.generated);
    })
  ],

  &#47;*
  Assignment of properties within an object literal can be separated by
  comma, as in JavaScript, or simply by newline.
   *&#47;
  AssignList: [
    o(&#39;&#39;, function() {
      return [];
    }), o(&#39;AssignObj&#39;, function() {
      return [$1];
    }), o(&#39;AssignList , AssignObj&#39;, function() {
      return $1.concat($3);
    }), o(&#39;AssignList OptComma TERMINATOR AssignObj&#39;, function() {
      return $1.concat($4);
    }), o(&#39;AssignList OptComma INDENT AssignList OptComma OUTDENT&#39;, function() {
      return $1.concat($4);
    })
  ],

  &#47;*
  Class definitions have optional bodies of prototype property assignments,
  and optional references to the superclass.
   *&#47;
  Class: [
    o(&#39;CLASS&#39;, function() {
      return new Class;
    }), o(&#39;CLASS Block&#39;, function() {
      return new Class(null, null, $2);
    }), o(&#39;CLASS EXTENDS Expression&#39;, function() {
      return new Class(null, $3);
    }), o(&#39;CLASS EXTENDS Expression Block&#39;, function() {
      return new Class(null, $3, $4);
    }), o(&#39;CLASS SimpleAssignable&#39;, function() {
      return new Class($2);
    }), o(&#39;CLASS SimpleAssignable Block&#39;, function() {
      return new Class($2, null, $3);
    }), o(&#39;CLASS SimpleAssignable EXTENDS Expression&#39;, function() {
      return new Class($2, $4);
    }), o(&#39;CLASS SimpleAssignable EXTENDS Expression Block&#39;, function() {
      return new Class($2, $4, $5);
    })
  ],

  &#47;*
  Ordinary function invocation, or a chained series of calls.
   *&#47;
  Invocation: [
    o(&#39;Value OptFuncExist Arguments&#39;, function() {
      return new Call($1, $3, $2);
    }), o(&#39;Invocation OptFuncExist Arguments&#39;, function() {
      return new Call($1, $3, $2);
    }), o(&#39;SUPER&#39;, function() {
      return new Call(&#39;super&#39;, [new Splat(new Literal(&#39;arguments&#39;))]);
    }), o(&#39;SUPER Arguments&#39;, function() {
      return new Call(&#39;super&#39;, $2);
    })
  ],

  &#47;*
  An optional existence check on a function.
   *&#47;
  OptFuncExist: [
    o(&#39;&#39;, function() {
      return false;
    }), o(&#39;FUNC_EXIST&#39;, function() {
      return true;
    })
  ],

  &#47;*
  The list of arguments to a function call.
   *&#47;
  Arguments: [
    o(&#39;CALL_START CALL_END&#39;, function() {
      return [];
    }), o(&#39;CALL_START ArgList OptComma CALL_END&#39;, function() {
      return $2;
    })
  ],

  &#47;*
  A reference to the *this* current object.
   *&#47;
  This: [
    o(&#39;THIS&#39;, function() {
      return new Value(new Literal(&#39;this&#39;));
    }), o(&#39;@&#39;, function() {
      return new Value(new Literal(&#39;this&#39;));
    })
  ],

  &#47;*
  A reference to a property on *this*.
   *&#47;
  ThisProperty: [
    o(&#39;@ Identifier&#39;, function() {
      return new Value(LOC(1)(new Literal(&#39;this&#39;)), [LOC(2)(new Access($2))], &#39;this&#39;);
    })
  ],

  &#47;*
  The array literal.
   *&#47;
  Array: [
    o(&#39;[ ]&#39;, function() {
      return new Arr([]);
    }), o(&#39;[ ArgList OptComma ]&#39;, function() {
      return new Arr($2);
    })
  ],

  &#47;*
  Inclusive and exclusive range dots.
   *&#47;
  RangeDots: [
    o(&#39;..&#39;, function() {
      return &#39;inclusive&#39;;
    }), o(&#39;...&#39;, function() {
      return &#39;exclusive&#39;;
    })
  ],

  &#47;*
  The CoffeeScript range literal.
   *&#47;
  Range: [
    o(&#39;[ Expression RangeDots Expression ]&#39;, function() {
      return new Range($2, $4, $3);
    })
  ],

  &#47;*
  Array slice literals.
   *&#47;
  Slice: [
    o(&#39;Expression RangeDots Expression&#39;, function() {
      return new Range($1, $3, $2);
    }), o(&#39;Expression RangeDots&#39;, function() {
      return new Range($1, null, $2);
    }), o(&#39;RangeDots Expression&#39;, function() {
      return new Range(null, $2, $1);
    }), o(&#39;RangeDots&#39;, function() {
      return new Range(null, null, $1);
    })
  ],

  &#47;*
  The **ArgList** is both the list of objects passed into a function call,
  as well as the contents of an array literal
  (i.e. comma-separated expressions). Newlines work as well.
   *&#47;
  ArgList: [
    o(&#39;Arg&#39;, function() {
      return [$1];
    }), o(&#39;ArgList , Arg&#39;, function() {
      return $1.concat($3);
    }), o(&#39;ArgList OptComma TERMINATOR Arg&#39;, function() {
      return $1.concat($4);
    }), o(&#39;INDENT ArgList OptComma OUTDENT&#39;, function() {
      return $2;
    }), o(&#39;ArgList OptComma INDENT ArgList OptComma OUTDENT&#39;, function() {
      return $1.concat($4);
    })
  ],

  &#47;*
  Valid arguments are Blocks or Splats.
   *&#47;
  Arg: [o(&#39;Expression&#39;), o(&#39;Splat&#39;)],

  &#47;*
  Just simple, comma-separated, required arguments (no fancy syntax). We need
  this to be separate from the **ArgList** for use in **Switch** blocks, where
  having the newlines wouldn&#39;t make sense.
   *&#47;
  SimpleArgs: [
    o(&#39;Expression&#39;), o(&#39;SimpleArgs , Expression&#39;, function() {
      return [].concat($1, $3);
    })
  ],

  &#47;*
  The variants of *try&#47;catch&#47;finally* exception handling blocks.
   *&#47;
  Try: [
    o(&#39;TRY Block&#39;, function() {
      return new Try($2);
    }), o(&#39;TRY Block Catch&#39;, function() {
      return new Try($2, $3[0], $3[1]);
    }), o(&#39;TRY Block FINALLY Block&#39;, function() {
      return new Try($2, null, null, $4);
    }), o(&#39;TRY Block Catch FINALLY Block&#39;, function() {
      return new Try($2, $3[0], $3[1], $5);
    })
  ],

  &#47;*
  A catch clause names its error and runs a block of code.
   *&#47;
  Catch: [
    o(&#39;CATCH Identifier Block&#39;, function() {
      return [$2, $3];
    }), o(&#39;CATCH Object Block&#39;, function() {
      return [LOC(2)(new Value($2)), $3];
    }), o(&#39;CATCH Block&#39;, function() {
      return [null, $2];
    })
  ],

  &#47;*
  Throw an exception object.
   *&#47;
  Throw: [
    o(&#39;THROW Expression&#39;, function() {
      return new Throw($2);
    })
  ],

  &#47;*
  Parenthetical expressions. Note that the **Parenthetical** is a **Value**,
  not an **Expression**, so if you need to use an expression in a place
  where only values are accepted, wrapping it in parentheses will always do
  the trick.
   *&#47;
  Parenthetical: [
    o(&#39;( Body )&#39;, function() {
      return new Parens($2);
    }), o(&#39;( INDENT Body OUTDENT )&#39;, function() {
      return new Parens($3);
    })
  ],

  &#47;*
  The condition portion of a while loop.
   *&#47;
  WhileSource: [
    o(&#39;WHILE Expression&#39;, function() {
      return new While($2);
    }), o(&#39;WHILE Expression WHEN Expression&#39;, function() {
      return new While($2, {
        guard: $4
      });
    }), o(&#39;UNTIL Expression&#39;, function() {
      return new While($2, {
        invert: true
      });
    }), o(&#39;UNTIL Expression WHEN Expression&#39;, function() {
      return new While($2, {
        invert: true,
        guard: $4
      });
    })
  ],

  &#47;*
  The while loop can either be normal, with a block of expressions to execute,
  or postfix, with a single expression. There is no do..while.
   *&#47;
  While: [
    o(&#39;WhileSource Block&#39;, function() {
      return $1.addBody($2);
    }), o(&#39;Statement  WhileSource&#39;, function() {
      return $2.addBody(LOC(1)(Block.wrap([$1])));
    }), o(&#39;Expression WhileSource&#39;, function() {
      return $2.addBody(LOC(1)(Block.wrap([$1])));
    }), o(&#39;Loop&#39;, function() {
      return $1;
    })
  ],
  Loop: [
    o(&#39;LOOP Block&#39;, function() {
      return new While(LOC(1)(new Literal(&#39;true&#39;))).addBody($2);
    }), o(&#39;LOOP Expression&#39;, function() {
      return new While(LOC(1)(new Literal(&#39;true&#39;))).addBody(LOC(2)(Block.wrap([$2])));
    })
  ],

  &#47;*
  Array, object, and range comprehensions, at the most generic level.
  Comprehensions can either be normal, with a block of expressions to execute,
  or postfix, with a single expression.
   *&#47;
  For: [
    o(&#39;Statement  ForBody&#39;, function() {
      return new For($1, $2);
    }), o(&#39;Expression ForBody&#39;, function() {
      return new For($1, $2);
    }), o(&#39;ForBody    Block&#39;, function() {
      return new For($2, $1);
    })
  ],
  ForBody: [
    o(&#39;FOR Range&#39;, function() {
      return {
        source: LOC(2)(new Value($2))
      };
    }), o(&#39;ForStart ForSource&#39;, function() {
      $2.own = $1.own;
      $2.name = $1[0];
      $2.index = $1[1];
      return $2;
    })
  ],
  ForStart: [
    o(&#39;FOR ForVariables&#39;, function() {
      return $2;
    }), o(&#39;FOR OWN ForVariables&#39;, function() {
      $3.own = true;
      return $3;
    })
  ],

  &#47;*
  An array of all accepted values for a variable inside the loop.
  This enables support for pattern matching.
   *&#47;
  ForValue: [
    o(&#39;Identifier&#39;), o(&#39;ThisProperty&#39;), o(&#39;Array&#39;, function() {
      return new Value($1);
    }), o(&#39;Object&#39;, function() {
      return new Value($1);
    })
  ],

  &#47;*
  An array or range comprehension has variables for the current element
  and (optional) reference to the current index. Or, *key, value*, in the case
  of object comprehensions.
   *&#47;
  ForVariables: [
    o(&#39;ForValue&#39;, function() {
      return [$1];
    }), o(&#39;ForValue , ForValue&#39;, function() {
      return [$1, $3];
    })
  ],

  &#47;*
  The source of a comprehension is an array or object with an optional guard
  clause. If it&#39;s an array comprehension, you can also choose to step through
  in fixed-size increments.
   *&#47;
  ForSource: [
    o(&#39;FORIN Expression&#39;, function() {
      return {
        source: $2
      };
    }), o(&#39;FOROF Expression&#39;, function() {
      return {
        source: $2,
        object: true
      };
    }), o(&#39;FORIN Expression WHEN Expression&#39;, function() {
      return {
        source: $2,
        guard: $4
      };
    }), o(&#39;FOROF Expression WHEN Expression&#39;, function() {
      return {
        source: $2,
        guard: $4,
        object: true
      };
    }), o(&#39;FORIN Expression BY Expression&#39;, function() {
      return {
        source: $2,
        step: $4
      };
    }), o(&#39;FORIN Expression WHEN Expression BY Expression&#39;, function() {
      return {
        source: $2,
        guard: $4,
        step: $6
      };
    }), o(&#39;FORIN Expression BY Expression WHEN Expression&#39;, function() {
      return {
        source: $2,
        step: $4,
        guard: $6
      };
    })
  ],
  Switch: [
    o(&#39;SWITCH Expression INDENT Whens OUTDENT&#39;, function() {
      return new Switch($2, $4);
    }), o(&#39;SWITCH Expression INDENT Whens ELSE Block OUTDENT&#39;, function() {
      return new Switch($2, $4, $6);
    }), o(&#39;SWITCH INDENT Whens OUTDENT&#39;, function() {
      return new Switch(null, $3);
    }), o(&#39;SWITCH INDENT Whens ELSE Block OUTDENT&#39;, function() {
      return new Switch(null, $3, $5);
    })
  ],
  Whens: [
    o(&#39;When&#39;), o(&#39;Whens When&#39;, function() {
      return $1.concat($2);
    })
  ],

  &#47;*
  An individual **When** clause, with action.
   *&#47;
  When: [
    o(&#39;LEADING_WHEN SimpleArgs Block&#39;, function() {
      return [[$2, $3]];
    }), o(&#39;LEADING_WHEN SimpleArgs Block TERMINATOR&#39;, function() {
      return [[$2, $3]];
    })
  ],

  &#47;*
  The most basic form of *if* is a condition and an action. The following
  if-related rules are broken up along these lines in order to avoid
  ambiguity.
   *&#47;
  IfBlock: [
    o(&#39;IF Expression Block&#39;, function() {
      return new If($2, $3, {
        type: $1
      });
    }), o(&#39;IfBlock ELSE IF Expression Block&#39;, function() {
      return $1.addElse(LOC(3, 5)(new If($4, $5, {
        type: $3
      })));
    })
  ],

  &#47;*
  The full complement of *if* expressions, including postfix one-liner
  *if* and *unless*.
   *&#47;
  If: [
    o(&#39;IfBlock&#39;), o(&#39;IfBlock ELSE Block&#39;, function() {
      return $1.addElse($3);
    }), o(&#39;Statement  POST_IF Expression&#39;, function() {
      return new If($3, LOC(1)(Block.wrap([$1])), {
        type: $2,
        statement: true
      });
    }), o(&#39;Expression POST_IF Expression&#39;, function() {
      return new If($3, LOC(1)(Block.wrap([$1])), {
        type: $2,
        statement: true
      });
    })
  ],

  &#47;*
  Arithmetic and logical operators, working on one or more operands.
  Here they are grouped by order of precedence. The actual precedence rules
  are defined at the bottom of the page. It would be shorter if we could
  combine most of these rules into a single generic *Operand OpSymbol Operand*
  -type rule, but in order to make the precedence binding possible, separate
  rules are necessary.
   *&#47;
  Operation: [
    o(&#39;UNARY Expression&#39;, function() {
      return new Op($1, $2);
    }), o(&#39;-     Expression&#39;, (function() {
      return new Op(&#39;-&#39;, $2);
    }), {
      prec: &#39;UNARY&#39;
    }), o(&#39;+     Expression&#39;, (function() {
      return new Op(&#39;+&#39;, $2);
    }), {
      prec: &#39;UNARY&#39;
    }), o(&#39;-- SimpleAssignable&#39;, function() {
      return new Op(&#39;--&#39;, $2);
    }), o(&#39;++ SimpleAssignable&#39;, function() {
      return new Op(&#39;++&#39;, $2);
    }), o(&#39;SimpleAssignable --&#39;, function() {
      return new Op(&#39;--&#39;, $1, null, true);
    }), o(&#39;SimpleAssignable ++&#39;, function() {
      return new Op(&#39;++&#39;, $1, null, true);
    }), o(&#39;Expression ?&#39;, function() {
      return new Existence($1);
    }), o(&#39;Expression +  Expression&#39;, function() {
      return new Op(&#39;+&#39;, $1, $3);
    }), o(&#39;Expression -  Expression&#39;, function() {
      return new Op(&#39;-&#39;, $1, $3);
    }), o(&#39;Expression MATH     Expression&#39;, function() {
      return new Op($2, $1, $3);
    }), o(&#39;Expression SHIFT    Expression&#39;, function() {
      return new Op($2, $1, $3);
    }), o(&#39;Expression COMPARE  Expression&#39;, function() {
      return new Op($2, $1, $3);
    }), o(&#39;Expression LOGIC    Expression&#39;, function() {
      return new Op($2, $1, $3);
    }), o(&#39;Expression RELATION Expression&#39;, function() {
      if ($2.charAt(0) === &#39;!&#39;) {
        return new Op($2.slice(1), $1, $3).invert();
      } else {
        return new Op($2, $1, $3);
      }
    }), o(&#39;SimpleAssignable COMPOUND_ASSIGN Expression&#39;, function() {
      return new Assign($1, $3, $2);
    }), o(&#39;SimpleAssignable COMPOUND_ASSIGN INDENT Expression OUTDENT&#39;, function() {
      return new Assign($1, $4, $2);
    }), o(&#39;SimpleAssignable COMPOUND_ASSIGN TERMINATOR Expression&#39;, function() {
      return new Assign($1, $4, $2);
    }), o(&#39;SimpleAssignable EXTENDS Expression&#39;, function() {
      return new Extends($1, $3);
    })
  ]
}</code></pre>
    <div class='docstring'>
  <p>In all of the rules that follow, you&#39;ll see the name of the nonterminal as
the key to a list of alternative matches. With each match&#39;s action, the
dollar-sign variables are provided by Jison as references to the value of
their numeric position, so in this rule:</p><pre><code>&quot;Expression UNLESS Expression&quot;
</code></pre><p><code>$1</code> would be the value of the first <code>Expression</code>, <code>$2</code> would be the token
for the <code>UNLESS</code> terminal, and <code>$3</code> would be the value of the second
<code>Expression</code>.</p>
</div>
<div class='tags'>
</div>
  </dd>
  <dt id='operators-variable'>
    operators
    =
  </dt>
  <dd>
    <pre><code class='coffeescript'>[[&#39;left&#39;, &#39;.&#39;, &#39;?.&#39;, &#39;::&#39;, &#39;?::&#39;], [&#39;left&#39;, &#39;CALL_START&#39;, &#39;CALL_END&#39;], [&#39;nonassoc&#39;, &#39;++&#39;, &#39;--&#39;], [&#39;left&#39;, &#39;?&#39;], [&#39;right&#39;, &#39;UNARY&#39;], [&#39;left&#39;, &#39;MATH&#39;], [&#39;left&#39;, &#39;+&#39;, &#39;-&#39;], [&#39;left&#39;, &#39;SHIFT&#39;], [&#39;left&#39;, &#39;RELATION&#39;], [&#39;left&#39;, &#39;COMPARE&#39;], [&#39;left&#39;, &#39;LOGIC&#39;], [&#39;nonassoc&#39;, &#39;INDENT&#39;, &#39;OUTDENT&#39;], [&#39;right&#39;, &#39;=&#39;, &#39;:&#39;, &#39;COMPOUND_ASSIGN&#39;, &#39;RETURN&#39;, &#39;THROW&#39;, &#39;EXTENDS&#39;], [&#39;right&#39;, &#39;FORIN&#39;, &#39;FOROF&#39;, &#39;BY&#39;, &#39;WHEN&#39;], [&#39;right&#39;, &#39;IF&#39;, &#39;ELSE&#39;, &#39;FOR&#39;, &#39;WHILE&#39;, &#39;UNTIL&#39;, &#39;LOOP&#39;, &#39;SUPER&#39;, &#39;CLASS&#39;], [&#39;left&#39;, &#39;POST_IF&#39;]]</code></pre>
    <div class='docstring'>
  <p>Operators at the top of this list have higher precedence than the ones lower
down. Following these rules is what makes <code>2 + 3 * 4</code> parse as:</p><pre><code>2 + (3 * 4)
</code></pre><p>And not:</p><pre><code>(2 + 3) * 4
</code></pre>
</div>
<div class='tags'>
</div>
  </dd>
  <dt id='tokens-variable'>
    tokens
    =
  </dt>
  <dd>
    <pre><code class='coffeescript'>[]</code></pre>
    <div class='docstring'>
  <p>Finally, now that we have our <strong>grammar</strong> and our <strong>operators</strong>, we can create
our <strong>Jison.Parser</strong>. We do this by processing all of our rules, recording all
terminals (every symbol which does not appear as the name of a rule above)
as &quot;tokens&quot;.</p>
</div>
<div class='tags'>
</div>
  </dd>
</dl>
      <h2>Method Summary</h2>
      <ul class='summary'>
  <li>
    <span class='signature'>
      <a href='#o-'>
        ~
(void)
<b>o</b><span>(patternString, action, options)</span>
      </a>
    </span>
    <span class='desc'>
      Our handy DSL for Jison grammar generation, thanks to <a href="http://github.com/creationix">Tim Caswell</a>.

    </span>
  </li>
</ul>
      <h2>Method Details</h2>
      <div class='methods'>
  <div class='method_details'>
    <p class='signature' id='o-'>
      ~
(void)
<b>o</b><span>(patternString, action, options)</span>
      <br>
    </p>
    <div class='docstring'>
  <p>Our handy DSL for Jison grammar generation, thanks to
<a href="http://github.com/creationix">Tim Caswell</a>. For every rule in the grammar,
we pass the pattern-defining string, the action to run, and extra options,
optionally. If no action is specified, we simply pass the value of the
previous nonterminal.</p>
</div>
<div class='tags'>
</div>
  </div>
</div>
    </div>
    <div id='footer'>
  January 21, 15 15:09:25 by
  <a href='https://github.com/coffeedoc/codo' title='CoffeeScript API documentation generator'>
    Codo
  </a>
  2.0.9
  &#10034;
  Press H to see the keyboard shortcuts
  &#10034;
  <a href='http://twitter.com/netzpirat' target='_parent'>@netzpirat</a>
  &#10034;
  <a href='http://twitter.com/_inossidabile' target='_parent'>@_inossidabile</a>
</div>
<iframe id='search_frame'></iframe>
<div id='fuzzySearch'>
  <input type='text'>
  <ol></ol>
</div>
<div id='help'>
  <p>
    Quickly fuzzy find classes, mixins, methods, file:
  </p>
  <ul>
    <li>
      <span>T</span>
      Open fuzzy finder dialog
    </li>
  </ul>
  <p>
    Control the navigation frame:
  </p>
  <ul>
    <li>
      <span>L</span>
      Toggle list view
    </li>
    <li>
      <span>C</span>
      Show class list
    </li>
    <li>
      <span>I</span>
      Show mixin list
    </li>
    <li>
      <span>F</span>
      Show file list
    </li>
    <li>
      <span>M</span>
      Show method list
    </li>
    <li>
      <span>E</span>
      Show extras list
    </li>
  </ul>
  <p>
    You can focus and blur the search input:
  </p>
  <ul>
    <li>
      <span>S</span>
      Focus search input
    </li>
    <li>
      <span>Esc</span>
      Blur search input
    </li>
  </ul>
</div>
  </body>
</html>