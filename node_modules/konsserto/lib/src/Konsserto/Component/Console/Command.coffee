###
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
###

cc = use('cli-color')
path = use('path')
readlineSync = use('readline-sync');

InputArgument = use('@Konsserto/Component/Console/Input/InputArgument')
InputDefinition = use('@Konsserto/Component/Console/Input/InputDefinition')
InputOption = use('@Konsserto/Component/Console/Input/InputOption')

#
# Command provides an architecture for bundle's commands
#
# @author Jessym Reziga <jessym@konsserto.com>
#
class Command


	constructor:(name) ->
		@synopsis = undefined
		@application = undefined
		@aliases = []
		@description = 'No description'
		@definition = undefined
		@help = 'No help'
		@applicationDefinitionMerged = false
		@applicationDefinitionMergedWithArgs = false
		@ignoreValidationErrors = false
		@definition = new InputDefinition()

		if name?
			@setName(name)

		@create()

		if !@name
			throw new Error('The command name cannot be empty')

	execute:(input) ->
		throw new Error('You must override the execute() method in the concrete command class.')

	setContainer:(@container) ->
		return this

	getContainer:() ->
		return @container

	setApplication:(@application) ->
		return this

	getApplication:() ->
		return @application

	setName:(name) ->
		@validateName(name)
		@name = name
		return this

	setDescription:(@description) ->
		return this

	setHelp:(@help) ->
		return this

	getName:() ->
		return @name

	getHelp:() ->
		return @help

	getDefinition:() ->
		return @definition

	getDescription:() ->
		return @description

	getAliases:() ->
		return @aliases

	ignoreValidationErrors:() ->
		@ignoreValidationErrors = true

	isEnabled:() ->
		return true

	getArrayChars:() ->
		if @chars?
			return @chars
		@chars = { 'top': '═' , 'top-mid': '╤' , 'top-left': '╔' , 'top-right': '╗'
		, 'bottom': '═' , 'bottom-mid': '╧' , 'bottom-left': '╚' , 'bottom-right': '╝'
		, 'left': '║' , 'left-mid': '╟' , 'mid': '─' , 'mid-mid': '┼'
		, 'right': '║' , 'right-mid': '╢' , 'middle': '│' }
		return @chars

	setArrayChars:(chars) ->
		@chars = chars

	getProcessedHelp:() ->
		name = @name
		executeCommand = process.argv[0]+' '+path.basename(process.argv[1])
		return @getHelp().replace(/%command.name%/g,name).replace(/%command.full_name%/g,executeCommand+' '+name)

	setSynopsis:(synopsis) ->

		if @synopsis == undefined
			@synopsis = @name+' '+synopsis

		return this

	run:(input) ->
		@getSynopsis()
		@mergeApplicationDefinition()

		try
			input.bind(@definition)
		catch e
			if !@ignoreValidationErrors
				throw e

		if input.isInteractive() && this.interact
			@interact(input)

		input.validate()
		return @execute(input)

	addOption:(name,shortcut,mode,description,def) ->
		@definition.addOption(new InputOption(name,shortcut,mode,description,def))
		return this

	addArgument:(name,mode,description,def) ->
		@definition.addArgument(new InputArgument(name,mode,descriptiondef))
		return this

	validateName:(name) ->

		if name == undefined || !name.match('^[^\:]+(\:[^\:]+)*$')
			throw new Error('Command name \''+name+'\' is invalid.')

	getSynopsis:() ->

		if @synopsis == undefined
			@synopsis = @name

			if @definition?
				@synopsis += ' '+@definition.getSynopsis()
			else
				@synopsis += ' [no arguments|no options]'

		return @synopsis

	setDefinition:(definition) ->

		if definition == undefined
			@definition.setDefinition(definition)
		else if definition.constructor.name == 'InputDefinition'
			@definition = definition
		else
			@definition.setDefinition(definition)

		@applicationDefinitionMerged = false;

	mergeApplicationDefinition:(mergeArgs) ->
		mergeArgs = true if mergeArgs == undefined

		if @application == undefined || ( @applicationDefinitionMerged == true && (@applicationDefinitionMergedWithArgs || !mergeArgs) )
			return

		if mergeArgs
			currentArguments = @definition.getArguments()
			@definition.setArguments(@application.getDefinition().getArguments())
			@definition.addArguments(currentArguments)

		@definition.addOptions(@application.getDefinition().getOptions())
		@applicationDefinitionMerged = true

		if mergeArgs
			@applicationDefinitionMergedWithArgs = true

	ask:(question,def = null,hidden = false) =>
		input = readlineSync.question(question,{noEchoBack: hidden})
		if def?
			return def if input == ''
		return input

	askCombo:(question,def,choices,caseSensitive = false) =>
		input = @ask(question,def)
		input = input.toLowerCase() if !caseSensitive

		while choices.indexOf(input) < 0
			input = @ask(question,def)
			input = input.toLowerCase() if !caseSensitive

		return input

	askHidden:(question,def) =>
		return @askAndValidate()

	askAndValidate:(question,def,callback,hidden = false) =>
		input = @ask(question,def,hidden)
		input = def if input == '' && def?
		return if callback? then callback(input) else input

	askHiddenAndValidate:(question,def,callback) =>
		return @askAndValidate(question,def,callback,true)

	askConfirmation:(question,def,caseSensitive = false) =>
		return @askCombo(question,def,['y','n','yes','no'],caseSensitive)

	write:(data) ->
		console.info(data)

	nl:() ->
		console.info('')


module.exports = Command;