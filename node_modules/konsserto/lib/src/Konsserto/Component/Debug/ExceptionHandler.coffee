###
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
###

cc = use('cli-color')
filesystem = use('fs')


# ExceptionHandler handle error in a clean way
#
# @author Jessym Reziga <jessym@konsserto.com>
class ExceptionHandler


  # Handle the exception thrown
  # @param {Object} exception The exception thrown
  # @param {Object} response The response object concerned
  # @param {Object} engine The template engine of the application
  # @param {Number} status The HTML Error code, default is 500
  # @param {Bollean} quiet Should the excpetion be quiet ?
  # @param {String} charset Charset concerned, default is utf-8
  @handle: (@exception, @response, @engine, @status = 500, @quiet = false, @charset = 'utf-8') ->
    @response.writeHeader(@status, {'Content-Type': 'text/html'});
    @response.end(@getContent())

  # @return {Object} The reponse with the parameters and the message to display on the screen
  @getContent: () ->
    errors = if @exception? then @exception.stack.split(' at ') else {}
    name = @exception.constructor.name
    message = @exception.message

    if (errors[1]? && errors[1].indexOf(':null:null') > 0)
      tmp = errors[0]
      name = errors[1].substr(0, errors[1].indexOf('.'))
      errors = errors.slice(3)
      errors.unshift(tmp)

    stack = errors.join(' at ')
    sources = @parse(errors)

    if !@quiet
      console.info('\n  ' + cc.white.bgRed(@exception.message))
      console.log(@exception.stack)

    return @engine.render('TwigBundle:Exception:exception.html.twig',
      {charset: @charset, errors: errors, stack: stack, name: name, message: message, sources: sources})


  # @return [Object] The error parsed with the good format to be managed by Konsserto
  @parse: (errors) ->
    more = []

    for error in errors
      i = error.indexOf(' (')
      method = null
      line = 0
      column = 0
      part = error
      file = null

      if i > 0
        method = error.substr(0, i)
        part = error.substr(i + 1, error.length)

      offset = part.match('([0-9]+):([0-9]+)')

      if offset? && offset.length >= 3
        line = parseInt(offset[1])
        column = parseInt(offset[2])
        file = part.substr(0, part.indexOf(offset[0]) - 1).replace('(', '')

        if filesystem.existsSync(file)
          source = filesystem.readFileSync(file).toString().split("\n");

        scopes = @getSourceCode(line, 3, source)
        more.push({method: method, file: file, line: line, col: column, scopes: scopes, start: line - 2})

    return more

  # @return [Object] The source code concerned by the error stack
  @getSourceCode: (needle, offset, array) ->
    scope = []
    max = array.length
    start = needle - offset
    end = needle + offset
    start = 0 if start < 0
    end = max if end > max

    for i in [start..end]
      scope.push(array[i])

    return scope

  # @param {String} charset The charset of the error
  @setCharset: (@charset) ->
    return this

  # @return {String} The charset of the error
  @getCharset: () ->
    return @charset


module.exports = ExceptionHandler
