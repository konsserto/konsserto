###
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
###

Crypt = use('@Konsserto/Component/Static/Crypt')
Q = use('q')

#
# Tools
#
# @author Jessym Reziga <jessym@konsserto.com>
#
class Tools


	@STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg
	@ARGUMENT_NAMES = /([^\s,]+)/g

	@endsWith:(stack,suffix) ->
		return stack.indexOf(suffix, stack.length - suffix.length) != -1

	@mergeObjects:(obj1,obj2,strict = false) ->
		obj3 = {};

		for k,v of obj1
			if strict && k.indexOf('_from') == 0
				continue
			else
				obj3[k] = v

		for k,v of obj2
			if strict && k.indexOf('_from') == 0
				continue
			else
				obj3[k] = v

		return obj3

	@firstKey:(obj1) ->

		for k,v of obj1
			return k

	@removeExt:(stack,ext) ->
		pos = stack.lastIndexOf(ext);
		return stack.substr(0,pos)

	@searchAndReplace:(oldValue,newValue,tab,lowercase) ->
		outTab = []

		for item in tab
			if lowercase
				if item.toLowerCase() == oldValue.toLowerCase()
					outTab.push(newValue)
				else
					outTab.push(item)
			else
				if item == oldValue
					outTab.push(newValue)
				else
					outTab.push(item)

		return outTab

	@toStringObject:(obj1) ->
		out = ''

		for k,v of obj1
			console.log(k+' '+v)
			out += k+v

		return out

	@toKeyObject:(obj1) ->
		return Crypt.md5(@toStringObject(obj1))

	@cloneObject:(obj) ->

		if not obj? or typeof obj isnt 'object'
			return obj

		if obj instanceof Date
			return new Date(obj.getTime())

		if obj instanceof RegExp
			flags = ''
			flags += 'g' if obj.global?
			flags += 'i' if obj.ignoreCase?
			flags += 'm' if obj.multiline?
			flags += 'y' if obj.sticky?
			return new RegExp(obj.source, flags)

		newInstance = new obj.constructor()

		for key of obj
			newInstance[key] = @cloneObject obj[key]

		return newInstance


	@extend = (a, b) ->

		for i of b
			g = b.__lookupGetter__(i)
			s = b.__lookupSetter__(i)

			if g or s
				a.__defineGetter__ i, g
				a.__defineSetter__ i, s
			else
				a[i] = b[i]

		return a

	@toArray:(object) ->
		tmp_array = []

		for key,value of object
			tmp_array.push(object[key]);

		return tmp_array

	@isInt:(str) ->
		return (str+'').match('^([0-9]+)$')

	@millis:() ->
		now = new Date().getTime() / 1000
		seconds = parseInt(now,10)
		return parseInt(seconds+''+Math.round((now - seconds) * 1000))

	@ucfirst:(str, tolower = false) ->
		str += ''
		f = str.charAt(0).toUpperCase();
		if tolower
			return f + str.substr(1).toLowerCase()
		return f + str.substr(1);

	@sortObject:(object) ->
		return `(function(s){var t={};Object.keys(s).sort().forEach(function(k){t[k]=s[k]});return t})(object)`

	@replaceFinalOccurence:(haystack, needle, replacement = '') ->
		return haystack.substr(0,haystack.lastIndexOf(needle)) + replacement

	@getFunctionParameters:(func) ->
		fnStr = func.toString().replace(Tools.STRIP_COMMENTS, '')
		result = fnStr.slice(fnStr.indexOf('(')+1, fnStr.indexOf(')')).match(Tools.ARGUMENT_NAMES)

		if !result?
			result = []

		return result

	@camelCase:(input,ucfirst = false) ->
		words = input.split(/[-_.]/)
		if words? && words.length >0
			out = if ucfirst then Tools.ucfirst(words.shift(),true) else words.shift()
			for word in words
				out += Tools.ucfirst(word,true)
			return out
		else
			return ''


	@call:(cb, parameters) ->
		func = undefined

		if typeof cb is "string"
			func = (if (typeof this[cb] is "function") then this[cb] else func = (new Function(null, "return " + cb))())
		else if Object::toString.call(cb) is "[object Array]"
			func = (if (typeof cb[0] is "string") then eval(cb[0] + "['" + cb[1] + "']") else func = cb[0][cb[1]])
		else func = cb  if typeof cb is "function"

		throw new Error(func + " is not a valid function")  if typeof func isnt "function"

		(if (typeof cb[0] is "string") then func.apply(eval(cb[0]), parameters) else (if (typeof cb[0] isnt "object") then func.apply(null, parameters) else func.apply(cb[0], parameters)))

	@strstr:(haysack,needle) ->
		column = 0
		haystack += ''
		column = haystack.indexOf(needle)
		return if column == -1 then false else haystack.slice(column)

	@strtr = (string, from, to) ->
		length = 0
		hash = new Array()
		tmp = ""
		if from.length < to.length
			length = from.length
		else
			length = to.length
		i = 0

		while i < length
			hash[from.charAt(i)] = to.charAt(i)
			i++
		j = 0

		while j < string.length
			c = string.charAt(j)
			if hash[c]
				tmp = tmp + hash[string.charAt(j)]
			else
				tmp = tmp + c
			j++
		tmp

	@array_unique:(array) ->
		unique = []
		for i in [1..array.length]
			if (unique.indexOf(array[i]) == -1)
				unique.push(array[i])
		return unique;

	@promiseWhile: (condition, body) ->
		done = Q.defer()
		_loop = () ->
			return done.resolve() unless condition()

			Q.when(body(), _loop, done.reject)

		Q.nextTick(_loop)

		return done.promise


module.exports = Tools

