
/*
 * This file is part of the Konsserto package.
 *
 * (c) Marvin Frachet <marvin@konsserto.com>
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var DirectoryFinder, File, FileFinder, fs;

fs = use('fs');

DirectoryFinder = use('@Konsserto/Component/Finder/DirectoryFinder');

File = use('@Konsserto/Component/Finder/File');

FileFinder = (function() {
  function FileFinder() {
    this.files = [];
  }

  FileFinder.prototype.getRecursive = function(rootDir) {
    var dir, dirFinder, directories, file, result, _i, _len;
    dirFinder = new DirectoryFinder();
    result = this.readFile(rootDir);
    dirFinder.getDirs(rootDir, true);
    directories = dirFinder.getResult();
    for (_i = 0, _len = directories.length; _i < _len; _i++) {
      dir = directories[_i];
      file = this.readFile(dir.getRelativePath());
      result = result.concat(file);
    }
    return this.files = result;
  };

  FileFinder.prototype.getFiles = function(rootDir) {
    return this.files = this.readFile(rootDir);
  };

  FileFinder.prototype.readFile = function(rootDir) {
    var file, filePath, files, result, stat, _i, _len;
    files = fs.readdirSync(rootDir);
    result = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      if (file[0] !== '.') {
        filePath = "" + rootDir + "/" + file;
        stat = fs.statSync(filePath);
        if (!stat.isDirectory()) {
          result.push(new File(file, rootDir));
        }
      }
    }
    return result;
  };

  FileFinder.prototype.name = function(name) {
    var file, new_files, _i, _len, _ref;
    new_files = [];
    _ref = this.files;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      if (file.getName().match(name)) {
        new_files.push(file);
      }
    }
    return this.files = new_files;
  };

  FileFinder.prototype.notName = function(name) {
    var file, new_files, _i, _len, _ref;
    new_files = [];
    _ref = this.files;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      if (!file.getName().match(name)) {
        new_files.push(file);
      }
    }
    return this.files = new_files;
  };

  FileFinder.prototype.size = function(size) {
    var comparizon, file, new_files, _i, _len, _ref;
    new_files = [];
    _ref = this.files;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      comparizon = eval("file.getSize()" + size);
      if (comparizon) {
        new_files.push(file);
      }
    }
    return this.files = new_files;
  };

  FileFinder.prototype.sortBy = function(orderby, orderway) {
    if (!orderway) {
      return this.files.sort(function(a, b) {
        if (a[orderby] >= b[orderby]) {
          return 1;
        } else {
          return -1;
        }
      });
    } else {
      return this.files.sort(function(a, b) {
        if (a[orderby] >= b[orderby]) {
          return -1;
        } else {
          return 1;
        }
      });
    }
  };

  FileFinder.prototype.getResult = function() {
    return this.files;
  };

  FileFinder.prototype.contains = function(content) {
    var file, result, _i, _len, _ref;
    result = [];
    _ref = this.files;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      if (file.getContent().indexOf(content) > -1) {
        result.push(file);
      }
    }
    this.files = result;
    return this;
  };

  FileFinder.prototype.ext = function(extension) {
    var file, result, _i, _len, _ref;
    extension = extension.indexOf('.') === 0 ? extension : '.' + extension;
    result = [];
    _ref = this.files;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      file = _ref[_i];
      if (file.getName().lastIndexOf(extension) >= 0) {
        result.push(file);
      }
    }
    this.files = result;
    return this;
  };

  return FileFinder;

})();

module.exports = FileFinder;
