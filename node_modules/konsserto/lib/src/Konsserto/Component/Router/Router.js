
/*
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 * (c) Marvin Frachet <marvin@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var Bundle, CONFIG, ExceptionHandler, MIDDLEWARES, MiddlewareDefinition, MiddlewareInstance, ROUTING, RouteDefinition, RouteInstance, Router, SECURITY, SOCKET, SocketDefinition, SocketInstance, bodyparser, cookieParser, csrf, express, session, wait, xssFilter,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

xssFilter = use('x-xss-protection');

bodyparser = use('body-parser');

cookieParser = use('cookie-parser');

csrf = use('csurf');

express = use('express');

session = use('express-session');

wait = use('wait.for');

MiddlewareDefinition = use('@Konsserto/Component/Middleware/MiddlewareDefinition');

MiddlewareInstance = use('@Konsserto/Component/Middleware/MiddlewareInstance');

MIDDLEWARES = use('/app/config/middleware');

Bundle = use('@Konsserto/Component/Bundle/Bundle');

CONFIG = use('/app/config/config');

ExceptionHandler = use('@Konsserto/Component/Debug/ExceptionHandler');

RouteDefinition = use('@Konsserto/Component/Router/RouteDefinition');

RouteInstance = use('@Konsserto/Component/Router/RouteInstance');

ROUTING = use('/app/config/routing');

SECURITY = use('/app/config/security');

SOCKET = use('/app/config/socket');

SocketDefinition = use('@Konsserto/Component/Socket/SocketDefinition');

SocketInstance = use('@Konsserto/Component/Socket/SocketInstance');

Router = (function() {
  function Router(application, container) {
    this.application = application;
    this.container = container;
    this.generate = __bind(this.generate, this);
    this.app = application.getMainApplication();
    this.hashRoutes = {};
    this.hashSockets = {};
    this.hashMiddlewares = {};
    this.host = '';
    this.router = express.Router();
    this.initSecurity();
    this.setHeaders();
    this.bodyParse();
    this.cookie_session_csrf();
    this.parseMiddlewares();
    this.parseRoutes();
    this.parseSockets();
    this.setHttpErrors();
    console.log('[Routing] Routes system OK');
  }

  Router.prototype.initSecurity = function() {
    this.app.use(xssFilter());
    return console.log('[Security] XSS Filter OK');
  };

  Router.prototype.parseMiddlewares = function() {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = MIDDLEWARES.length; _i < _len; _i++) {
      item = MIDDLEWARES[_i];
      if (item.middleware && item.name) {
        _results.push(this.addMiddleware(item));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Router.prototype.importMiddlewares = function(item) {
    var middleware, middlewares, _i, _len, _results;
    middlewares = use(item.middleware);
    _results = [];
    for (_i = 0, _len = middlewares.length; _i < _len; _i++) {
      middleware = middlewares[_i];
      _results.push(this.addMiddleware(middleware));
    }
    return _results;
  };

  Router.prototype.addMiddleware = function(registeredMiddleware) {
    var middlewareDefinition;
    middlewareDefinition = new MiddlewareDefinition(registeredMiddleware);
    this.hashMiddlewares[middlewareDefinition.getName()] = middlewareDefinition;
    return this.linkMiddleware(middlewareDefinition);
  };

  Router.prototype.linkMiddleware = function(middleware) {
    var bundle, middlewareInstance;
    bundle = this.application.getBundle(middleware.getBundleName());
    middlewareInstance = new MiddlewareInstance(middleware, bundle.fetchMiddleware(middleware.getMiddlewareName()));
    middlewareInstance.getController().setContainer(this.container).setApplication(this.app);
    return this.app.all(middleware.getPattern(), (function(_this) {
      return function(req, res, next) {
        middlewareInstance.setRequest(req);
        middlewareInstance.setResponse(res);
        middlewareInstance.setNext(next);
        return middlewareInstance.getResponse();
      };
    })(this));
  };

  Router.prototype.cookie_session_csrf = function() {
    this.router.use(cookieParser(CONFIG.secret));
    this.router.use(session({
      secret: CONFIG.secret,
      key: 'ks.connect.sid',
      saveUninitialized: true,
      resave: true
    }));
    return this.router.use(csrf());
  };

  Router.prototype.parseRoutes = function() {
    var item, _i, _len, _results;
    this.app.use('/', this.router);
    _results = [];
    for (_i = 0, _len = ROUTING.length; _i < _len; _i++) {
      item = ROUTING[_i];
      if (item.resource !== void 0) {
        _results.push(this.importRoutes(item));
      } else {
        _results.push(this.addRoute(item));
      }
    }
    return _results;
  };

  Router.prototype.importRoutes = function(item) {
    var prefix, route, routes, _i, _len, _results;
    routes = use(item.resource);
    if (item.prefix != null) {
      prefix = item.prefix.indexOf('/') !== 0 ? '/' : '';
      prefix += item.prefix;
    }
    _results = [];
    for (_i = 0, _len = routes.length; _i < _len; _i++) {
      route = routes[_i];
      _results.push(this.addRoute(route, prefix));
    }
    return _results;
  };

  Router.prototype.addRoute = function(registeredRoute, prefix) {
    var routeDefinition;
    if (prefix == null) {
      prefix = null;
    }
    routeDefinition = new RouteDefinition(registeredRoute, prefix);
    this.hashRoutes[routeDefinition.getName()] = routeDefinition;
    return this.linkRoute(routeDefinition);
  };

  Router.prototype.linkRoute = function(route) {
    var bundle, pattern, routeInstance;
    bundle = this.application.getBundle(route.getBundleName());
    routeInstance = new RouteInstance(route, bundle.fetchController(route.getControllerName()));
    routeInstance.getController().setContainer(this.container).setApplication(this.app);
    pattern = route.getPattern();
    return this.app[route.getHttpMethod()](pattern, (function(_this) {
      return function(req, res, next) {
        _this.host = req.headers['x-forwarded-host'] != null ? req.headers['x-forwarded-host'] + ':' + CONFIG.port : req.headers.host;
        routeInstance.setRequest(req);
        routeInstance.setResponse(res);
        routeInstance.setNext(next);
        return _this.container.get('Kernel').handle(routeInstance);
      };
    })(this));
  };

  Router.prototype.bodyParse = function() {
    if (CONFIG.bodyParser) {
      switch (CONFIG.bodyParser.type) {
        case 'json':
          return this.app.use(bodyparser.json());
        case 'urlencoded':
          if (CONFIG.bodyParser.config) {
            return this.app.use(bodyparser.urlencoded(CONFIG.bodyParser.config));
          } else {
            return this.app.use(bodyparser.urlencoded({
              extended: false
            }));
          }
          break;
        default:
          this.app.use(bodyparser.json());
          if (CONFIG.bodyParser.config) {
            return this.app.use(bodyparser.urlencoded(CONFIG.bodyParser.config));
          } else {
            return this.app.use(bodyparser.urlencoded({
              extended: false
            }));
          }
      }
    } else {
      this.app.use(bodyparser.json());
      return this.app.use(bodyparser.urlencoded({
        extended: false
      }));
    }
  };

  Router.prototype.setHeaders = function() {
    return this.app.all('*', (function(_this) {
      return function(req, res, next) {
        var header, _i, _len, _ref;
        if (SECURITY.global['headers_allowed'] != null) {
          _ref = SECURITY.global['headers_allowed'];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            header = _ref[_i];
            res.header(header.name, header.value);
          }
        }
        return next();
      };
    })(this));
  };

  Router.prototype.setHttpErrors = function() {
    this.app.all('/', (function(_this) {
      return function(req, res, next) {
        var engine;
        if (global.env === 'dev') {
          engine = _this.container.get('Templating');
          res.writeHeader(200, {
            'Content-Type': 'text/html'
          });
          return res.end(engine.render('TwigBundle:Welcome:welcome.html.twig', {
            charset: 'utf-8'
          }));
        } else {
          engine = _this.container.get('Templating');
          ExceptionHandler.handle(new Error('404 Page not found'), res, engine, 404, true);
        }
        return next();
      };
    })(this));
    return this.app.use((function(_this) {
      return function(req, res, next) {
        var engine;
        engine = _this.container.get('Templating');
        return ExceptionHandler.handle(new Error('404 Page not found'), res, engine, 404, true);
      };
    })(this));
  };

  Router.prototype.generate = function(name, parameters) {
    var path, route;
    route = this.getRoute(name);
    path = route.inflateArguments(parameters);
    return path;
  };

  Router.prototype.setRouter = function(router) {
    this.router = router;
    return this;
  };

  Router.prototype.getHost = function() {
    return this.host;
  };

  Router.prototype.getRoutes = function() {
    return this.hashRoutes;
  };

  Router.prototype.getRoute = function(name) {
    if (this.hashRoutes[name] != null) {
      return this.hashRoutes[name];
    }
    throw new Error('There is no route with name: ' + name);
  };

  Router.prototype.getApplication = function() {
    return this.app;
  };

  Router.prototype.getSecurity = function() {
    return this.security;
  };

  Router.prototype.parseSockets = function() {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = SOCKET.length; _i < _len; _i++) {
      item = SOCKET[_i];
      if (item.resource !== void 0) {
        _results.push(this.importSockets(item));
      } else {
        _results.push(this.addSocket(item));
      }
    }
    return _results;
  };

  Router.prototype.importSockets = function(item) {
    var prefixed, socket, sockets, _i, _len, _results;
    sockets = use(item.resource);
    if (item.prefix !== void 0 && item.prefix.indexOf('/') !== 0) {
      prefixed = item.prefix;
    }
    _results = [];
    for (_i = 0, _len = sockets.length; _i < _len; _i++) {
      socket = sockets[_i];
      _results.push(this.addSocket(socket, prefixed));
    }
    return _results;
  };

  Router.prototype.addSocket = function(registeredSocket, prefix) {
    var socketDefinition;
    socketDefinition = new SocketDefinition(registeredSocket, prefix);
    this.hashSockets[socketDefinition.getName()] = socketDefinition;
    return this.linkSocket(socketDefinition);
  };

  Router.prototype.linkSocket = function(socket) {
    var bundle, event, socketInstance;
    bundle = this.application.getBundle(socket.getBundleName());
    socketInstance = new SocketInstance(socket, bundle.fetchController(socket.getControllerName()));
    socketInstance.getController().setContainer(this.container).setApplication(this.app);
    event = socket.getEvent();
    if (!socket.isConnectionListener()) {
      return this.app.io.route(event, (function(_this) {
        return function(req) {
          _this.host = req.headers.host;
          socketInstance.setRequest(req);
          socketInstance.setResponse(req.res);
          return socketInstance.getControllerMethod()(req.data);
        };
      })(this));
    } else {
      return this.app.io.on('connection', (function(_this) {
        return function(data) {
          var e;
          if (socket.isAsynchronous()) {
            try {
              return socketInstance.getControllerMethod()(data);
            } catch (_error) {
              e = _error;
              throw new Error('An error occured in method \'' + socketInstance.getMethod() + '\' in ' + socketInstance.getControllerName() + '.' + '\n' + e.message);
            }
          } else {
            return wait.launchFiber(function() {
              try {
                return socketInstance.getControllerMethod()(data);
              } catch (_error) {
                e = _error;
                throw new Error('An error occured in method \'' + socketInstance.getMethod() + '\' in ' + socketInstance.getControllerName() + '.' + '\n' + e.message);
              }
            });
          }
        };
      })(this));
    }
  };

  return Router;

})();

module.exports = Router;
