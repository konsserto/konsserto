###
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 * (c) Marvin Frachet <marvin@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
###

bodyparser = use('body-parser')
cookieParser = use('cookie-parser')
csrf = use('csurf')
express = use('express')
session = use('express-session')
wait = use('wait.for')
MiddlewareDefinition = use('@Konsserto/Component/Middleware/MiddlewareDefinition')
MiddlewareInstance = use('@Konsserto/Component/Middleware/MiddlewareInstance')
MIDDLEWARES = use('/app/config/middleware')
Bundle = use('@Konsserto/Component/Bundle/Bundle')
CONFIG = use('/app/config/config')
ExceptionHandler = use('@Konsserto/Component/Debug/ExceptionHandler')
RouteDefinition = use('@Konsserto/Component/Router/RouteDefinition')
RouteInstance = use('@Konsserto/Component/Router/RouteInstance')
ROUTING = use('/app/config/routing')
SECURITY = use('/app/config/security')
SOCKET = use('/app/config/socket')
SocketDefinition = use('@Konsserto/Component/Socket/SocketDefinition')
SocketInstance = use('@Konsserto/Component/Socket/SocketInstance')

#
# Router
#
# @author Jessym Reziga <jessym@konsserto.com>
#
class Router

	constructor: (@application, @container) ->
    @app = application.getMainApplication()
    @hashRoutes = {}
    @hashSockets = {}
    @hashMiddlewares = {}
    @host = ''
    @router = express.Router()
    @setHeaders()
    @bodyParse()
    @cookie_session_csrf()
    @parseMiddlewares()
    @parseRoutes()
    @parseSockets()
    @setHttpErrors()
    console.log '[Routing] Routes system OK'

  parseMiddlewares: ->
    for item in MIDDLEWARES
      if item.middleware
        @addMiddleware(item)

  importMiddlewares: (item) ->
    middlewares = use(item.middleware)
    for middleware in middlewares
      @addMiddleware(middleware)

  addMiddleware: (registeredMiddleware) ->
    middlewareDefinition = new MiddlewareDefinition(registeredMiddleware)
    @hashMiddlewares[middlewareDefinition.getName()] = middlewareDefinition
    @linkMiddleware(middlewareDefinition)

  linkMiddleware: (middleware) ->
    bundle = @application.getBundle(middleware.getBundleName())
    middlewareInstance = new MiddlewareInstance(middleware, bundle.fetchMiddleware(middleware.getMiddlewareName()))
    middlewareInstance.getController().setContainer(@container).setApplication(@app)

    @app.all(middleware.getPattern(), (req, res, next) =>
      middlewareInstance.setRequest(req)
      middlewareInstance.setResponse(res)
      middlewareInstance.setNext(next)
      middlewareInstance.getResponse()
    );

  cookie_session_csrf: ->
    @router.use(cookieParser(CONFIG.secret))
    @router.use(session({secret: CONFIG.secret, key: 'ks.connect.sid', saveUninitialized: true, resave: true}));
    @router.use(csrf())

	parseRoutes: ->
		@app.use('/', @router)

		for item in ROUTING
			if item.resource != undefined
				@importRoutes(item)
			else
				@addRoute(item)

	importRoutes: (item) ->
		routes = use(item.resource)

		if item.prefix?
			prefix = if item.prefix.indexOf('/') != 0 then '/' else ''
			prefix += item.prefix

		for route in routes
			@addRoute(route, prefix)

	addRoute: (registeredRoute, prefix = null) ->
		routeDefinition = new RouteDefinition(registeredRoute, prefix)
		@hashRoutes[routeDefinition.getName()] = routeDefinition
		@linkRoute(routeDefinition)

	linkRoute: (route) ->
		bundle = @application.getBundle(route.getBundleName())
		routeInstance = new RouteInstance(route, bundle.fetchController(route.getControllerName()))
		routeInstance.getController().setContainer(@container).setApplication(@app)
		pattern = route.getPattern()

		@app[route.getHttpMethod()](pattern, (req, res, next) =>
			@host = if req.headers['x-forwarded-host']? then req.headers['x-forwarded-host'] + ':' + CONFIG.port else req.headers.host
			routeInstance.setRequest(req)
			routeInstance.setResponse(res)
			routeInstance.setNext(next)
			@container.get('Kernel').handle(routeInstance)
		)

	bodyParse: () ->
    if CONFIG.bodyParser
      switch CONFIG.bodyParser.type
        when 'json'
          @app.use bodyparser.json()
        when 'urlencoded'
          if CONFIG.bodyParser.config
            @app.use bodyparser.urlencoded(CONFIG.bodyParser.config)
          else
            @app.use bodyparser.urlencoded({extended: false})
        else
          @app.use bodyparser.json()
          if CONFIG.bodyParser.config
            @app.use bodyparser.urlencoded(CONFIG.bodyParser.config)
          else
            @app.use bodyparser.urlencoded({extended: false})
    else
      @app.use bodyparser.json()
      @app.use bodyparser.urlencoded({extended: false})

	setHeaders: () ->
		@app.all '*', (req, res, next) =>
			if SECURITY.global['headers_allowed']?
				for header in SECURITY.global['headers_allowed']
					res.header header.name, header.value
			next()

	setHttpErrors: () ->
		@app.all '/', (req, res, next) =>
			if global.env == 'dev'
				engine = @container.get('Templating')
				res.writeHeader(200, {'Content-Type': 'text/html'});
				return res.end(engine.render('TwigBundle:Welcome:welcome.html.twig', {charset: 'utf-8'}))
			else
				engine = @container.get('Templating')
				ExceptionHandler.handle(new Error('404 Page not found'), res, engine, 404, true)

			next()

		@app.use((req, res, next) =>
			engine = @container.get('Templating')
			ExceptionHandler.handle(new Error('404 Page not found'), res, engine, 404, true)
		)

	generate: (name, parameters) =>
		route = @getRoute(name)
		path = route.inflateArguments(parameters)
		return path

	setRouter: (@router) ->
		return this

	getHost: () ->
		return @host

	getRoutes: () ->
		return @hashRoutes

	getRoute: (name) ->
		if @hashRoutes[name]?
			return @hashRoutes[name]
		throw new Error('There is no route with name: ' + name)

	getApplication: () ->
		return @app

	getSecurity: () ->
		return @security

	parseSockets: ->
		for item in SOCKET
			if item.resource != undefined
				@importSockets(item)
			else
				@addSocket(item)

	importSockets: (item) ->
		sockets = use(item.resource)
		prefixed = item.prefix if item.prefix != undefined && item.prefix.indexOf('/') != 0

		for socket in sockets
			@addSocket(socket, prefixed)

	addSocket: (registeredSocket, prefix) ->
		socketDefinition = new SocketDefinition(registeredSocket, prefix)
		@hashSockets[socketDefinition.getName()] = socketDefinition
		@linkSocket(socketDefinition)

	linkSocket: (socket) ->
		bundle = @application.getBundle(socket.getBundleName())
		socketInstance = new SocketInstance(socket, bundle.fetchController(socket.getControllerName()))
		socketInstance.getController().setContainer(@container).setApplication(@app)
		event = socket.getEvent()

		if !socket.isConnectionListener()
			@app.io.route(event, (req) =>
				@host = req.headers.host
				socketInstance.setRequest(req)
				socketInstance.setResponse(req.res)
				socketInstance.getControllerMethod()(req.data)
			)
		else
			@app.io.on('connection', (data) =>
				if (socket.isAsynchronous())
					try
						socketInstance.getControllerMethod()(data)
					catch e
						throw new Error('An error occured in method \'' + socketInstance.getMethod() + '\' in ' +
						socketInstance.getControllerName() + '.' + '\n' + e.message)
				else
					wait.launchFiber(()=>
						try
							socketInstance.getControllerMethod()(data)
						catch e
							throw new Error('An error occured in method \'' + socketInstance.getMethod() + '\' in ' +
							socketInstance.getControllerName() + '.' + '\n' + e.message)
					)
			)


module.exports = Router