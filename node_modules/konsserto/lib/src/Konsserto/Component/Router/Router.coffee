###
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 * (c) Marvin Frachet <marvin@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
###

xssFilter = use('x-xss-protection')
bodyparser = use('body-parser')
cookieParser = use('cookie-parser')
csrf = use('csurf')
express = use('express')
session = use('express-session')
wait = use('wait.for')
MiddlewareDefinition = use('@Konsserto/Component/Middleware/MiddlewareDefinition')
MiddlewareInstance = use('@Konsserto/Component/Middleware/MiddlewareInstance')
MIDDLEWARES = use('/app/config/routing').middlewares
Bundle = use('@Konsserto/Component/Bundle/Bundle')
CONFIG = use('/app/config/config')
ExceptionHandler = use('@Konsserto/Component/Debug/ExceptionHandler')
RouteDefinition = use('@Konsserto/Component/Router/RouteDefinition')
RouteInstance = use('@Konsserto/Component/Router/RouteInstance')
ROUTING = use('/app/config/routing').routes
SECURITY = use('/app/config/security')
SOCKET = use('/app/config/routing').sockets
SocketDefinition = use('@Konsserto/Component/Socket/SocketDefinition')
SocketInstance = use('@Konsserto/Component/Socket/SocketInstance')
logger = use('morgan')
cc = use('cli-color')

# Router
# @author Jessym Reziga <jessym@konsserto.com>
# @author Marvin Frachet <marvin@konsserto.com>
class Router

  # Class constructor
  # @param {Application} application The unique instance of the application
  # @param {ServiceContainer} container The unique instance of the service container
  constructor: (@application, @container) ->
    @app = application.getMainApplication()
    @hashRoutes = {}
    @hashSockets = {}
    @hashMiddlewares = {}
    @host = ''
    @router = express.Router()
    @initHttpLogger()
    @initSecurity()
    @setHeaders()
    @bodyParse()
    @cookie_session_csrf()
    @parseMiddlewares()
    @parseRoutes()
    @parseSockets()
    @setHttpErrors()
    console.log '[Routing] Routes system OK'

  # Initilize the HTTP logger
  initHttpLogger: ()->
    if CONFIG.loggerHTTP
      accessLogStream = use('fs').createWriteStream('./app/logs/http.log', {flags: 'a'})
      @app.use logger('combined', {stream: accessLogStream})
      console.log '[Logger] HTTP Logger OK'

  # Initilize the security
  initSecurity: ()->
    if SECURITY.xssProtection is undefined || SECURITY.xssProtection is true
      console.log '[Security] Protection against XSS attacks explicitly OK'
      @app.use(xssFilter())

  # Parse the middlewares
  parseMiddlewares: () ->
    for item in MIDDLEWARES
      if item.middleware && item.name
        @addMiddleware(item)

  # Add the middleware creating his definition
  # @param {Object} registeredMiddleware The middleware item from the config/routing.middleware file
  addMiddleware: (registeredMiddleware) ->
    middlewareDefinition = new MiddlewareDefinition(registeredMiddleware)
    @hashMiddlewares[middlewareDefinition.getName()] = middlewareDefinition
    @linkMiddleware(middlewareDefinition)

  # Link the middleware to the application
  # @param {MiddlewareDefinition} middleware The middleware definition
  linkMiddleware: (middleware) ->
    bundle = @application.getBundle(middleware.getBundleName())
    middlewareInstance = new MiddlewareInstance(middleware, bundle.fetchMiddleware(middleware.getMiddlewareName()))
    middlewareInstance.getController().setContainer(@container).setApplication(@app)

    @app.all(middleware.getPattern(), (req, res, next) =>
      middlewareInstance.setRequest(req)
      middlewareInstance.setResponse(res)
      middlewareInstance.setNext(next)
      middlewareInstance.getResponse()
    )

  # Prepare the cookie session CSRF to use it with the forms
  cookie_session_csrf: () ->
    if CONFIG.secret && CONFIG.secret != ''
      @router.use(cookieParser(CONFIG.secret))
      @router.use(session({secret: CONFIG.secret, key: 'ks.connect.sid', saveUninitialized: true, resave: true}))
      @router.use(csrf())
    else
      console.log cc.red('[WARNING] CSRF protection disabled, you didn\'t specified a secret key in the /app/config/config file !')

  # Parse the routes
  parseRoutes: () ->
    @app.use('/', @router)
    for item in ROUTING
      if item.resource != undefined
        @importRoutes(item)
      else
        @addRoute(item)

  # Import the route and prefix it
  importRoutes: (item) ->
    routes = use(item.resource)
    if item.prefix?
      prefix = if item.prefix.indexOf('/') != 0 then '/' else ''
      prefix += item.prefix
    for route in routes
      @addRoute(route, prefix)

  # Create the route definition
  # @param {Object} item The route item from the config/routing.routes file
  # @param {String} prefix The prefix of the route
  addRoute: (registeredRoute, prefix = null) ->
    routeDefinition = new RouteDefinition(registeredRoute, prefix)
    @hashRoutes[routeDefinition.getName()] = routeDefinition
    @linkRoute(routeDefinition)


  # Link the route to the application
  # @param {RouteDefinition} route The route definition
  linkRoute: (route) ->
    bundle = @application.getBundle(route.getBundleName())
    routeInstance = new RouteInstance(route, bundle.fetchController(route.getControllerName()))
    routeInstance.getController().setContainer(@container).setApplication(@app)
    pattern = route.getPattern()
    @app[route.getHttpMethod()](pattern, (req, res, next) =>
      @host = if req.headers['x-forwarded-host']? then req.headers['x-forwarded-host'] + ':' + CONFIG.port else req.headers.host
      routeInstance.setRequest(req)
      routeInstance.setResponse(res)
      routeInstance.setNext(next)
      @container.get('Kernel').handle(routeInstance)
    )

  # Initialize the body parser express middleware
  bodyParse: () ->
    if CONFIG.bodyParser
      switch CONFIG.bodyParser.type
        when 'json'
          @app.use bodyparser.json()
        when 'urlencoded'
          if CONFIG.bodyParser.config
            @app.use bodyparser.urlencoded(CONFIG.bodyParser.config)
          else
            @app.use bodyparser.urlencoded({extended: false})
        else
          @app.use bodyparser.json()
          if CONFIG.bodyParser.config
            @app.use bodyparser.urlencoded(CONFIG.bodyParser.config)
          else
            @app.use bodyparser.urlencoded({extended: false})
    else
      @app.use bodyparser.json()
      @app.use bodyparser.urlencoded({extended: false})


  # Initialize the headers of the responses
  setHeaders: () ->
    if SECURITY.headers_allowed?
      console.log '[Security] Headers allowed :'
      for header in SECURITY.headers_allowed
        console.log '  [' + header.name + '] : ' + header.value

    @app.all '*', (req, res, next) =>
      if SECURITY.headers_allowed?
        for header in SECURITY.headers_allowed
          res.header header.name, header.value
      next()

  # Initialize the http errors
  setHttpErrors: () ->
    @app.all '/', (req, res, next) =>
      if global.env == 'dev'
        engine = @container.get('Templating')
        res.writeHeader(200, {'Content-Type': 'text/html'});
        return res.end(engine.render('TwigBundle:Welcome:welcome.html.twig', {charset: 'utf-8'}))
      else
        engine = @container.get('Templating')
        ExceptionHandler.handle(new Error('404 Page not found'), res, engine, 404, true)
      next()
    @app.use((req, res, next) =>
      engine = @container.get('Templating')
      ExceptionHandler.handle(new Error('404 Page not found'), res, engine, 404, true)
    )

  # Generate the route parameters
  # @param {String} name The name of the route
  # @param [Object] parameters The parameters of the route
  generate: (name, parameters) =>
    route = @getRoute(name)
    path = route.inflateArguments(parameters)
    return path

  # @param {Object} The express router
  setRouter: (@router) ->
    return this

  # @return {String} The host
  getHost: () ->
    return @host

  # @return [RouteDefinition] The routes
  getRoutes: () ->
    return @hashRoutes

  # Get a route from her name
  # @param {String} name The name of the route
  # @return [RouteDefinition] The routes
  getRoute: (name) ->
    if @hashRoutes[name]?
      return @hashRoutes[name]
    throw new Error('There is no route with name: ' + name)

  # @return {Application} The application
  getApplication: () ->
    return @app

  # @return {Object} The security of the router
  getSecurity: () ->
    return @security


  # Parse the socket from the config/routing.sockets file
  parseSockets: ->
    for item in SOCKET
      if item.resource != undefined
        @importSockets(item)
      else
        @addSocket(item)

  # Import the socket from the config file
  # @param {Object} item The config route to import
  importSockets: (item) ->
    sockets = use(item.resource)
    prefixed = item.prefix if item.prefix != undefined && item.prefix.indexOf('/') != 0
    for socket in sockets
      @addSocket(socket, prefixed)

  # Create the socket definitions with the prefix
  # @param {Object} registeredSocket The registered socket
  # @param {String} prefix The socket prefix
  addSocket: (registeredSocket, prefix) ->
    socketDefinition = new SocketDefinition(registeredSocket, prefix)
    @hashSockets[socketDefinition.getName()] = socketDefinition
    @linkSocket(socketDefinition)

  # Link the socket to the router
  # @param {SocketDefinition} socket The socket definition
  linkSocket: (socket) ->
    bundle = @application.getBundle(socket.getBundleName())
    socketInstance = new SocketInstance(socket, bundle.fetchController(socket.getControllerName()))
    socketInstance.getController().setContainer(@container).setApplication(@app)
    event = socket.getEvent()
    if !socket.isConnectionListener()
      @app.io.route(event, (req) =>
        @host = req.headers.host
        socketInstance.setRequest(req)
        socketInstance.setResponse(req.res)
        socketInstance.getControllerMethod()(req.data)
      )
    else
      @app.io.on('connection', (data) =>
        if (socket.isAsynchronous())
          try
            socketInstance.getControllerMethod()(data)
          catch e
            throw new Error('An error occured in method \'' + socketInstance.getMethod() + '\' in ' +
              socketInstance.getControllerName() + '.' + '\n' + e.message)
        else
          wait.launchFiber(()=>
            try
              socketInstance.getControllerMethod()(data)
            catch e
              throw new Error('An error occured in method \'' + socketInstance.getMethod() + '\' in ' +
                socketInstance.getControllerName() + '.' + '\n' + e.message)
          )
      )


module.exports = Router