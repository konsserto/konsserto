###
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
###

filesystem = use('fs')

GLOBAL_SERVICES = use('/app/config/services')
KERNEL_SERVICES = use('@Konsserto/Component/DependencyInjection/services/services')
ServiceDefinition = use('@Konsserto/Component/DependencyInjection/ServiceDefinition')
ServiceInstance = use('@Konsserto/Component/DependencyInjection/ServiceInstance')


# ServiceContainer injects services in a container accessible on an application
#
# @author Jessym Reziga <jessym@konsserto.com>
class ServiceContainer


  # Class constructor
  # @param {Kernel} kernel The kernel of Konsserto
  constructor: (@kernel) ->
    @services = {}
    @loaded = {}
    @set('Kernel', @kernel)
    @set('Container', this)
    @setupKernel()
    @setupGlobalAndBundles()
    console.log '[Container] DI Services OK'

  # Setting up the Kernel configurations
  setupKernel: () ->
    @addServiceInstance(KERNEL_SERVICES, 'konsserto')
    @updateForInjectors()

  # Setting up the global and bundles configurations
  setupGlobalAndBundles: () ->
    # /app/config/services.js
    @addServiceInstance(GLOBAL_SERVICES, 'global')
    # /src/bundles/.../config/services.js
    bundles = @get('Application').getBundles()
    for bundleName,bundle of bundles
      if filesystem.existsSync(bundle.getConfigPath() + '/services.js')
        services = use(bundle.getConfigNamespace() + '/services')
        @addServiceInstance(services)
    @updateForInjectors()

  # Create the services instance a unique time
  # @param [Object] services Liste of the services to create and instanciate only one time
  # @param {String} type Type of the service (like global), default is null
  addServiceInstance: (services, type = null) ->
    for service in services
      serviceDefinition = new ServiceDefinition(service, type)
      serviceInstance = new ServiceInstance(serviceDefinition)
      @services[serviceDefinition.getName()] = serviceInstance

  # Compile the service passed in parameter
  # @param {ServiceInstance} service The service instance to compile
  compile: (service) ->
    for serviceArgument in service.getDefinition().getServiceArgumentsOnly()
      @compile(@getServiceInstance(serviceArgument.getValue()))

    if (!service.instanceExists())
      service.evaluateInstance(this)

  # Check if old services (with args) need dependencies from latest registered services /!\ For Kernel purpose only !
  updateForInjectors: () =>
    for name, service of @services
      @compile(service)

  # @param {ServiceDefinition} serviceDefinition The service definition to instanciate
  # Inject a service manually => Need to updateForInjectors after /!\ For Kernel purpose only !
  inject: (serviceDefinition, value) =>
    serviceInstance = new ServiceInstance(serviceDefinition)
    serviceInstance.setInstance(value)
    @services[serviceDefinition.getName()] = serviceInstance

  # Get service by name
  # @param {String} name The name of the service to return
  # @param {Boolean} debug Should I use debug mode ? default is true
  # @return {Object} The service concerned
  get: (name, debug = true) =>
    formatName = name.toLowerCase()
    if @has(formatName)
      return @services[formatName].getInstance()
    if debug
      throw new Error('Can\'t get the service : ' + name)
    return null

  # Check if a service exists
  # @param {String} name The name of the service to check
  # @return {Boolean} True if exists, false in the other cases
  has: (name) =>
    formatName = name.toLowerCase()
    if @services[formatName]?
      return true
    return false

  # Get the service definition
  # @param {String} name The name of the service to find
  # @return {ServiceDefinition} The service definition or null
  getServiceDefinition: (name) =>
    formatName = name.toLowerCase()
    if @has(formatName)
      return @getServiceInstance(formatName).getDefinition()
    return null

  # Get the service instance
  # @param {String} name The name of the service to find
  # @return {ServiceInstance} The service instance or null
  getServiceInstance: (name) =>
    formatName = name.toLowerCase()
    if @has(formatName)
      return @services[formatName]
    return null

  # Set a service instance
  # @param {String} name The name of the service
  # @param {Object} value The value to inject in the ServiceDefinition
  # @param [Object] args The args to inject in the ServiceDefinition
  set: (name, value, args = []) ->
    if @has(name)
      throw new Error('The service ' + name + ' is already registered in container')
    service = value.constructor
    if service._fromUsed? && service._fromUsed.charAt(0) == '@'
      serviceDefinition = new ServiceDefinition({
        name: name,
        _class: service._fromUsed,
        args: args
      }, 'kernel')
      @inject(serviceDefinition, value)
    else
      throw new Error('The definition of service ' + name + ' is not a Konsserto Service')


module.exports = ServiceContainer
