
/*
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var Bundle, EntityDefinition, EntityInstance, EntityManager, EntityRepository, Finder, Tools, cc, filesystem,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

cc = use('cli-color');

filesystem = use('fs');

Bundle = use('@Konsserto/Component/Bundle/Bundle');

EntityDefinition = use('@Konsserto/Component/ORM/EntityDefinition');

EntityInstance = use('@Konsserto/Component/ORM/EntityInstance');

EntityRepository = use('@Konsserto/Component/ORM/EntityRepository');

Finder = use('@Konsserto/Component/Finder/Finder');

Tools = use('@Konsserto/Component/Static/Tools');

EntityManager = (function() {
  EntityManager.UNMANAGED = 0;

  EntityManager.MANAGED = 1;

  EntityManager.DELETED = 2;

  function EntityManager(application) {
    this.application = application;
    this.getRepository = __bind(this.getRepository, this);
    this.remove = __bind(this.remove, this);
    this.flush = __bind(this.flush, this);
    this.persist = __bind(this.persist, this);
    this.load = __bind(this.load, this);
    this.entities = {};
    this.logicalToPhysical = {};
    this.persistedStack = [];
    this.dirtyEntities = {};
  }

  EntityManager.prototype.load = function(database) {
    var bundle, entityDefinition, entityFiles, entityInstance, file, name, _i, _len, _ref;
    this.database = database;
    this.entities = {};
    this.logicalToPhysical = {};
    this.persistedStack = [];
    this.dirtyEntities = {};
    _ref = this.application.getBundles();
    for (name in _ref) {
      bundle = _ref[name];
      entityFiles = new Finder().files()["in"](bundle.getEntityPath()).ext('coffee').contains('@model').end();
      for (_i = 0, _len = entityFiles.length; _i < _len; _i++) {
        file = entityFiles[_i];
        entityDefinition = new EntityDefinition(file, bundle, this.dirtyEntities);
        entityInstance = new EntityInstance(entityDefinition, this.database, this);
        this.logicalToPhysical[entityDefinition.getLogicalPath()] = entityDefinition.getPath();
        this.entities[entityDefinition.getPath()] = entityInstance;
        this.dirtyEntities[entityDefinition.getLogicalPath()] = {};
      }
    }
    return this.handleAssociations();
  };

  EntityManager.prototype.handleAssociations = function() {
    var association, entityInstance, model, path, _i, _len, _ref, _ref1, _results;
    _ref = this.entities;
    _results = [];
    for (path in _ref) {
      entityInstance = _ref[path];
      model = entityInstance.getDefinition().getModel();
      _ref1 = model.getHasOneAssociations();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        association = _ref1[_i];
        entityInstance.getModelInstance().hasOne(association.name, this.resolve(association.mappedBy).getModelInstance(), association.options);
      }
      _results.push((function() {
        var _j, _len1, _ref2, _results1;
        _ref2 = model.getHasManyAssociations();
        _results1 = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          association = _ref2[_j];
          _results1.push(entityInstance.getModelInstance().hasMany(association.name, this.resolve(association.mappedBy).getModelInstance(), association.options));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  EntityManager.prototype.persist = function(entity) {
    var repository;
    if (entity.hasOwnProperty('_logicalPath')) {
      repository = this.resolve(entity._logicalPath()).getRepository();
      this.addPersistableEntity(repository, entity, EntityManager.MANAGED);
    } else {
      repository = this.entities[entity.constructor._fromUsed].getRepository();
      this.addPersistableEntity(repository, entity, EntityManager.UNMANAGED);
    }
    return true;
  };

  EntityManager.prototype.addPersistableEntity = function(repository, entity, state) {
    return this.persistedStack.push({
      repository: repository,
      entity: entity,
      state: state
    });
  };

  EntityManager.prototype.flush = function() {
    var assoc, associations, base, e, entity, entityDefinition, entityInstance, field, fields, item, logicalPath, managedObject, model, modelInstance, repository, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref;
    _ref = this.persistedStack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      repository = item.repository;
      entity = item.entity;
      entityInstance = repository.getEntityInstance();
      modelInstance = entityInstance.getModelInstance();
      entityDefinition = entityInstance.getDefinition();
      model = entityDefinition.getModel();
      logicalPath = entityDefinition.getLogicalPath();
      switch (item.state) {
        case EntityManager.DELETED:
          entity.remove(repository);
          break;
        case EntityManager.UNMANAGED:
          try {
            if ((this.dirtyEntities[logicalPath][entity.id] != null)) {
              base = this.dirtyEntities[logicalPath][entity.id];
              fields = Object.keys(base);
              associations = model.getOneAndManyAssociations();
              for (_j = 0, _len1 = fields.length; _j < _len1; _j++) {
                field = fields[_j];
                base[field] = entity[field];
                if (associations.indexOf(field) === -1) {
                  base.markAsDirty(field);
                }
              }
              for (_k = 0, _len2 = associations.length; _k < _len2; _k++) {
                assoc = associations[_k];
                base[assoc] = entity[assoc];
              }
              repository.save(base);
            } else {
              managedObject = repository.create(entity);
              this.dirtyEntities[logicalPath][managedObject.id] = managedObject;
              entity['_logicalPath'] = (function(_this) {
                return function() {
                  return logicalPath;
                };
              })(this);
            }
          } catch (_error) {
            e = _error;
            throw new Error('Can\'t flush the ' + entity.constructor.name + ' entity, ' + e);
          }
          break;
        default:
          if ((this.dirtyEntities[logicalPath][entity.id] != null)) {
            base = this.dirtyEntities[logicalPath][entity.id];
            fields = Object.keys(base);
            associations = model.getOneAndManyAssociations();
            for (_l = 0, _len3 = fields.length; _l < _len3; _l++) {
              field = fields[_l];
              base[field] = entity[field];
              if (associations.indexOf(field) === -1) {
                base.markAsDirty(field);
              }
            }
            for (_m = 0, _len4 = associations.length; _m < _len4; _m++) {
              assoc = associations[_m];
              base[assoc] = entity[assoc];
            }
            repository.save(base);
          } else {
            repository.save(entity);
          }
      }
    }
    this.persistedStack = [];
    return true;
  };

  EntityManager.prototype.remove = function(entity) {
    if (entity.hasOwnProperty('_logicalPath')) {
      this.addPersistableEntity(this.resolve(entity._logicalPath()).getModelInstance(), entity, EntityManager.DELETED);
      return true;
    }
    throw new Error('Can\'t remove an unpersisted entity');
  };

  EntityManager.prototype.getRepository = function(path) {
    if (this.has(path)) {
      return this.resolve(path).getRepository();
    }
    throw new Error('Can\'t find the ' + path + ' repository');
  };

  EntityManager.prototype.has = function(path) {
    return this.resolve(path).getRepository().hasRepository();
  };

  EntityManager.prototype.resolve = function(path) {
    return this.entities[this.logicalToPhysical[path]];
  };

  EntityManager.prototype.getEntitiesInstance = function() {
    return this.entities;
  };

  return EntityManager;

})();

module.exports = EntityManager;
