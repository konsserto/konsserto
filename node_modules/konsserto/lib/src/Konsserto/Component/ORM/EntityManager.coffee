###
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
###

cc = use('cli-color')
filesystem = use('fs')

Bundle = use('@Konsserto/Component/Bundle/Bundle')
EntityDefinition = use('@Konsserto/Component/ORM/EntityDefinition')
EntityInstance = use('@Konsserto/Component/ORM/EntityInstance')
EntityRepository = use('@Konsserto/Component/ORM/EntityRepository')
Finder = use('@Konsserto/Component/Finder/Finder')
Tools = use('@Konsserto/Component/Static/Tools')

#
# EntityManager
#
# @author Jessym Reziga <jessym@konsserto.com>
#
class EntityManager


	@UNMANAGED = 0
	@MANAGED = 1
	@DELETED = 2

	constructor:(@application) ->
		@entities = {}
		@logicalToPhysical = {}
		@persistedStack = []
		@dirtyEntities = {}

	load:(@database) =>
		@entities = {}
		@logicalToPhysical = {}
		@persistedStack = []
		@dirtyEntities = {}

		for name,bundle of @application.getBundles()
			entityFiles = new Finder().files().in(bundle.getEntityPath()).ext('coffee').contains('@model').end()
			for file in entityFiles
				entityDefinition = new EntityDefinition(file, bundle,@dirtyEntities)
				entityInstance = new EntityInstance(entityDefinition, @database, this)
				@logicalToPhysical[entityDefinition.getLogicalPath()] = entityDefinition.getPath()
				@entities[entityDefinition.getPath()] = entityInstance
				@dirtyEntities[entityDefinition.getLogicalPath()] = {}

		@handleAssociations()

	handleAssociations:() ->
		for path,entityInstance of @entities
			model = entityInstance.getDefinition().getModel()

			for association in model.getHasOneAssociations()
				entityInstance.getModelInstance().hasOne(
					association.name,
					@resolve(association.mappedBy).getModelInstance(),
					association.options
				);

			for association in model.getHasManyAssociations()
				entityInstance.getModelInstance().hasMany(
					association.name,
					@resolve(association.mappedBy).getModelInstance(),
					association.options
				);



	persist:(entity) =>
		if (entity.hasOwnProperty('_logicalPath'))
			repository = @resolve(entity._logicalPath()).getRepository()
			@addPersistableEntity(repository, entity, EntityManager.MANAGED)
		else
			repository = @entities[entity.constructor._fromUsed].getRepository()
			@addPersistableEntity(repository, entity, EntityManager.UNMANAGED)

		return true

	addPersistableEntity:(repository,entity,state) ->
		@persistedStack.push({repository:repository,entity:entity,state:state})

	flush:() =>
		for item in @persistedStack
			repository = item.repository
			entity = item.entity
			entityInstance = repository.getEntityInstance()
			modelInstance = entityInstance.getModelInstance()
			entityDefinition = entityInstance.getDefinition()
			model = entityDefinition.getModel()
			logicalPath = entityDefinition.getLogicalPath()

			switch item.state
				when EntityManager.DELETED
					entity.remove(repository)
				when EntityManager.UNMANAGED
					try
						if (@dirtyEntities[logicalPath][entity.id]?)
							base = @dirtyEntities[logicalPath][entity.id]
							fields = Object.keys(base)
							associations = model.getOneAndManyAssociations()

							for field in fields
								base[field] = entity[field]
								if (associations.indexOf(field) == -1)
									base.markAsDirty(field)

							for assoc in associations
								base[assoc] = entity[assoc]

							repository.save(base)
						else
							managedObject = repository.create(entity)
							@dirtyEntities[logicalPath][managedObject.id] = managedObject
							entity['_logicalPath'] = () => return logicalPath
					catch e
						throw new Error('Can\'t flush the '+entity.constructor.name+' entity, '+e)
				else
					if (@dirtyEntities[logicalPath][entity.id]?)
						base = @dirtyEntities[logicalPath][entity.id]
						fields = Object.keys(base)
						associations = model.getOneAndManyAssociations()

						for field in fields
							base[field] = entity[field]
							if (associations.indexOf(field) == -1)
								base.markAsDirty(field)

						for assoc in associations
							base[assoc] = entity[assoc]

						repository.save(base)
					else
						repository.save(entity)

		@persistedStack = []

		return true

	remove:(entity) =>
		if (entity.hasOwnProperty('_logicalPath'))
			@addPersistableEntity(@resolve(entity._logicalPath()).getModelInstance(),entity,EntityManager.DELETED)
			return true

		return throw new Error('Can\'t remove an unpersisted entity')

	getRepository:(path) =>

		if @has(path)
			return @resolve(path).getRepository()

		return throw new Error('Can\'t find the '+path+' repository')

	has:(path) ->
		return @resolve(path).getRepository().hasRepository()

	resolve:(path) ->
		return @entities[@logicalToPhysical[path]]

	getEntitiesInstance:() ->
		return @entities


module.exports = EntityManager