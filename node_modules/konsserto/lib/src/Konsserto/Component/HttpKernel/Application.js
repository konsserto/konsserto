
/*
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var Application, BUNDLES, SECURITY, Tools, cc, express, filesystem;

cc = use('cli-color');

express = use('express.io');

filesystem = use('fs');

BUNDLES = use('/app/config/bundles');

SECURITY = use('/app/config/security');

Tools = use('@Konsserto/Component/Static/Tools');

Application = (function() {
  function Application(stat) {
    if (!stat) {
      this.app = express();
      if (this.sslActive()) {
        this.app.https(this.sslOptions()).io();
      } else {
        this.app.http().io();
      }
      this.app.use(express["static"](process.cwd(), 'web'));
      this.app.set('views', '');
    }
    this.registerBundles();
  }

  Application.prototype.registerBundles = function() {
    var bundle, name, _i, _len, _results;
    this.appBundles = [];
    _results = [];
    for (_i = 0, _len = BUNDLES.length; _i < _len; _i++) {
      bundle = BUNDLES[_i];
      name = bundle.getName();
      if (Tools.endsWith(name.toLowerCase(), 'bundle')) {
        _results.push(this.appBundles[name] = bundle);
      } else {
        throw new Error('A bundle name must ends with \'bundle\'');
      }
    }
    return _results;
  };

  Application.prototype.hasBundle = function(name) {
    if (this.appBundles[name] != null) {
      return true;
    }
    return false;
  };

  Application.prototype.getBundle = function(name) {
    return this.appBundles[name];
  };

  Application.prototype.getBundles = function() {
    return this.appBundles;
  };

  Application.prototype.getMainApplication = function() {
    return this.app;
  };

  Application.prototype.start = function(port) {
    if (this.sslActive()) {
      this.sslCheckPaths();
      console.log(cc.white.bgGreen('[Power ON]') + ' Listening on port #' + port + ' | pid: ' + process.pid + ' [HTTPS & SSL]');
    } else {
      console.log(cc.white.bgGreen('[Power ON]') + ' Listening on port #' + port + ' | pid: ' + process.pid + ' [HTTP]');
    }
    return this.app.listen(port);
  };

  Application.prototype.sslActive = function() {
    if ((SECURITY.ssl_protocol != null) && (SECURITY.ssl_protocol['active'] != null) && SECURITY.ssl_protocol['active']) {
      return true;
    }
    return false;
  };

  Application.prototype.sslCheckPaths = function() {
    if (!SECURITY.ssl_protocol['key'] || SECURITY.ssl_protocol['key'] === "") {
      throw new Error('The SSL Key path has not been filled in the \'server\' configuration file.');
    }
    if (!SECURITY.ssl_protocol['certificate'] || SECURITY.ssl_protocol['certificate'] === "") {
      throw new Error(' The SSL Certificate path has not been filled in the \'server\' configuration file.');
    }
  };

  Application.prototype.sslOptions = function() {
    var options;
    options = {
      key: filesystem.readFileSync(SECURITY.ssl_protocol['key']),
      cert: filesystem.readFileSync(SECURITY.ssl_protocol['certificate'])
    };
    return options;
  };

  return Application;

})();

module.exports = Application;
