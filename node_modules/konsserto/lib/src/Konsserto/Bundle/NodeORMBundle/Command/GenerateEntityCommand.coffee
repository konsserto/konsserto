###
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
###

cc = use('cli-color')
file_helper = use('fs')
path = use('path')
Table = use('cli-table');

Command = use('@Konsserto/Component/Console/Command')
Filesystem = use('@Konsserto/Component/Filesystem/Filesystem')
InputArgument = use('@Konsserto/Component/Console/Input/InputArgument')
InputOption = use('@Konsserto/Component/Console/Input/InputOption')
Tools = use('@Konsserto/Component/Static/Tools');

#
# GenerateEntityCommand
#
# @author Jessym Reziga <jessym@konsserto.com>
#
class GenerateEntityCommand extends Command


	create:() ->
		@setName('generate:entity')
		@setDescription('Generate an entity for persistence')
		@setDefinition([new InputArgument('target',InputArgument.OPTIONAL,'The target directory','web')])
		@setHelp('  The command %command.name% installs bundle assets into a given directory.\n Example:\n  %command.full_name% web')




	execute: (input) ->
		@nl()
		process.exit(0)

	interact: (input)->
		table = new Table({chars:@getArrayChars()});
		table.push(['Konsserto Entity Generator'])
		@write('\n\n'+table.toString()+'\n')
		@write("""This command allow you to generate a skeleton for a Node ORM 2 entity

		Choose a bundle and write the entity name (like FooBundleBlogBundle:Post).
		""")

		application = @getContainer().get('Application')

		bundle = ''
		name = ''
		fields = []
		fieldTypeAvailable = ['text','textarea','number','integer','boolean','date','datetime','enum','object','point','binary','serial']
		_loop = true

		while _loop
			entity = @ask('\nEntity name : ')

			if entity == 'exit' || entity == 'quit' || entity == '!q'
				_loop = false
				process.exit(0)

			match = entity.match('^([a-zA-Z0-9]+):([a-zA-Z0-9]+)$')

			entity_split = entity.split(':')
			bundle = entity_split[0]
			name = entity_split[1]

			if match == undefined || match == null || match.length <= 0
				@write('  The entity name is invalid.')
				continue

			if !application.hasBundle(bundle)
				@write('  The bundle \''+bundle+'\' doesn\'t exists.')
				continue

			_loop = false

		objBundle = application.getBundle(bundle)

		# FIELD LIST
		fieldList = ''
		fieldList += (cc.bgBlue.white(fieldItem)+',') for fieldItem in fieldTypeAvailable
		fieldList = fieldList.substr(0,fieldList.length-1)

		table = new Table({chars:@getArrayChars()});
		table.push(['Available field types'])
		@write('\n'+table.toString()+'\n')
		@write(fieldList)

		while (field = @ask('\nNew field name (press <return> to stop adding fields): ')) != ''
			match = field.match('^([a-zA-Z0-9_]+)$')

			if match == undefined || match == null || match.length <= 0
				@write('  The field name contains invalid characters.')
				continue
			else
				while (type = @askCombo('Field type [text]: ','text',fieldTypeAvailable))
					options = null
					switch type
						when 'text'
							while true
								options = @askAndValidate('Field length [255]: ','255')
								match = parseInt(options)
								if match? && match >= 0 && match <= 255
									break;
								else
									continue
						when 'enum'
							values = []
							while (options = @ask('\nField add value (press <return> to stop adding value): ')) != ''
								values.push(options)
							options = values
						when 'datetime'
							options = 'time'
							type = 'date'

					fields.push({name:field,type:type,options:options})
					break

		@registerEntity(name,bundle,objBundle,fields)
		@registerRepository(name,bundle,objBundle,fields)

		return 0

	registerEntity:(name,bundle,objBundle,fields) ->

		path = Filesystem.mktree(process.cwd()+'/',objBundle.getEntityPath('').replace(/\\/,'/').split('/'),755,false)
		file = path + name+'.coffee'
		repository = (objBundle.getRepositoryNamespace() + '/' + name+'Repository').replace(/\\/,'/')

		outFields = ''
		outGetSet = ''

		for field in fields
			ccNameUC = Tools.camelCase(field.name,true)
			ccName = Tools.camelCase(field.name)
			option = ''

			switch field.type
				when 'text'
					size = parseInt(field.options)
					option = ', size: '+size if field.options? && size > 0
				when 'enum'
					values = ''
					for value in field.options
						values += "'"+value+"'"
						values += ',' if _j != (field.options.length-1)
					option = ', values: ['+values+']' if field.options?
				when 'date'
					if field.options?
						option = ', time: true'
					else
						option = ', time: false'
				when 'textarea'
					field.type = 'text'
					option = ', big: true'

			outFields += """\t\t\t#{ccName}: {type: '#{field.type}'#{option}}"""
			outFields += ',\n' if _i != (fields.length-1)

			outGetSet += """
				\tget#{ccNameUC}:() ->
					\treturn @#{ccName}

				\tset#{ccNameUC}:(@#{ccName}) ->
					\treturn this\n\n
			"""
			;

		file_helper.writeFileSync(file,"""
		class #{name}


			@model = {
				table: '#{name.toLowerCase()}',
				repository: '#{repository}',
				fields: {
					id: { type: "serial", key: true },
		#{outFields}
				},
				associations: {
					hasOne: [],
					hasMany: []
				}

			}

			constructor: ()->
				return this

		#{outGetSet}

		module.exports = #{name}
		""")


	registerRepository:(name,bundle,objBundle,fields) ->
		path_repository = Filesystem.mktree(process.cwd()+'/',objBundle.getRepositoryPath('').replace(/\\/,'/').split('/'),755,false)
		file_repository = path_repository + name+'Repository.coffee'
		file_helper.writeFileSync(file_repository,"""
		EntityRepository = use('@Konsserto/Component/ORM/EntityRepository')

		class #{name}Repository extends EntityRepository




		module.exports = #{name}Repository
		""")



module.exports = GenerateEntityCommand;

