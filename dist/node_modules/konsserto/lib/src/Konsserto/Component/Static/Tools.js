
/*
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var Crypt, Q, Tools;

Crypt = use('@Konsserto/Component/Static/Crypt');

Q = use('q');

Tools = (function() {
  function Tools() {}

  Tools.STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

  Tools.ARGUMENT_NAMES = /([^\s,]+)/g;

  Tools.endsWith = function(stack, suffix) {
    return stack.indexOf(suffix, stack.length - suffix.length) !== -1;
  };

  Tools.mergeObjects = function(obj1, obj2, strict) {
    var k, obj3, v;
    if (strict == null) {
      strict = false;
    }
    obj3 = {};
    for (k in obj1) {
      v = obj1[k];
      if (strict && k.indexOf('_from') === 0) {
        continue;
      } else {
        obj3[k] = v;
      }
    }
    for (k in obj2) {
      v = obj2[k];
      if (strict && k.indexOf('_from') === 0) {
        continue;
      } else {
        obj3[k] = v;
      }
    }
    return obj3;
  };

  Tools.firstKey = function(obj1) {
    var k, v;
    for (k in obj1) {
      v = obj1[k];
      return k;
    }
  };

  Tools.removeExt = function(stack, ext) {
    var pos;
    pos = stack.lastIndexOf(ext);
    return stack.substr(0, pos);
  };

  Tools.searchAndReplace = function(oldValue, newValue, tab, lowercase) {
    var item, outTab, _i, _len;
    outTab = [];
    for (_i = 0, _len = tab.length; _i < _len; _i++) {
      item = tab[_i];
      if (lowercase) {
        if (item.toLowerCase() === oldValue.toLowerCase()) {
          outTab.push(newValue);
        } else {
          outTab.push(item);
        }
      } else {
        if (item === oldValue) {
          outTab.push(newValue);
        } else {
          outTab.push(item);
        }
      }
    }
    return outTab;
  };

  Tools.toStringObject = function(obj1) {
    var k, out, v;
    out = '';
    for (k in obj1) {
      v = obj1[k];
      console.log(k + ' ' + v);
      out += k + v;
    }
    return out;
  };

  Tools.toKeyObject = function(obj1) {
    return Crypt.md5(this.toStringObject(obj1));
  };

  Tools.cloneObject = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = this.cloneObject(obj[key]);
    }
    return newInstance;
  };

  Tools.extend = function(a, b) {
    var g, i, s;
    for (i in b) {
      g = b.__lookupGetter__(i);
      s = b.__lookupSetter__(i);
      if (g || s) {
        a.__defineGetter__(i, g);
        a.__defineSetter__(i, s);
      } else {
        a[i] = b[i];
      }
    }
    return a;
  };

  Tools.toArray = function(object) {
    var key, tmp_array, value;
    tmp_array = [];
    for (key in object) {
      value = object[key];
      tmp_array.push(object[key]);
    }
    return tmp_array;
  };

  Tools.isInt = function(str) {
    return (str + '').match('^([0-9]+)$');
  };

  Tools.millis = function() {
    var now, seconds;
    now = new Date().getTime() / 1000;
    seconds = parseInt(now, 10);
    return parseInt(seconds + '' + Math.round((now - seconds) * 1000));
  };

  Tools.ucfirst = function(str, tolower) {
    var f;
    if (tolower == null) {
      tolower = false;
    }
    str += '';
    f = str.charAt(0).toUpperCase();
    if (tolower) {
      return f + str.substr(1).toLowerCase();
    }
    return f + str.substr(1);
  };

  Tools.sortObject = function(object) {
    return (function(s){var t={};Object.keys(s).sort().forEach(function(k){t[k]=s[k]});return t})(object);
  };

  Tools.replaceFinalOccurence = function(haystack, needle, replacement) {
    if (replacement == null) {
      replacement = '';
    }
    return haystack.substr(0, haystack.lastIndexOf(needle)) + replacement;
  };

  Tools.getFunctionParameters = function(func) {
    var fnStr, result;
    fnStr = func.toString().replace(Tools.STRIP_COMMENTS, '');
    result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(Tools.ARGUMENT_NAMES);
    if (result == null) {
      result = [];
    }
    return result;
  };

  Tools.camelCase = function(input, ucfirst) {
    var out, word, words, _i, _len;
    if (ucfirst == null) {
      ucfirst = false;
    }
    words = input.split(/[-_.]/);
    if ((words != null) && words.length > 0) {
      out = ucfirst ? Tools.ucfirst(words.shift(), true) : words.shift();
      for (_i = 0, _len = words.length; _i < _len; _i++) {
        word = words[_i];
        out += Tools.ucfirst(word, true);
      }
      return out;
    } else {
      return '';
    }
  };

  Tools.call = function(cb, parameters) {
    var func;
    func = void 0;
    if (typeof cb === "string") {
      func = (typeof this[cb] === "function" ? this[cb] : func = (new Function(null, "return " + cb))());
    } else if (Object.prototype.toString.call(cb) === "[object Array]") {
      func = (typeof cb[0] === "string" ? eval(cb[0] + "['" + cb[1] + "']") : func = cb[0][cb[1]]);
    } else {
      if (typeof cb === "function") {
        func = cb;
      }
    }
    if (typeof func !== "function") {
      throw new Error(func + " is not a valid function");
    }
    if (typeof cb[0] === "string") {
      return func.apply(eval(cb[0]), parameters);
    } else {
      if (typeof cb[0] !== "object") {
        return func.apply(null, parameters);
      } else {
        return func.apply(cb[0], parameters);
      }
    }
  };

  Tools.strstr = function(haysack, needle) {
    var column;
    column = 0;
    haystack += '';
    column = haystack.indexOf(needle);
    if (column === -1) {
      return false;
    } else {
      return haystack.slice(column);
    }
  };

  Tools.strtr = function(string, from, to) {
    var c, hash, i, j, length, tmp;
    length = 0;
    hash = new Array();
    tmp = "";
    if (from.length < to.length) {
      length = from.length;
    } else {
      length = to.length;
    }
    i = 0;
    while (i < length) {
      hash[from.charAt(i)] = to.charAt(i);
      i++;
    }
    j = 0;
    while (j < string.length) {
      c = string.charAt(j);
      if (hash[c]) {
        tmp = tmp + hash[string.charAt(j)];
      } else {
        tmp = tmp + c;
      }
      j++;
    }
    return tmp;
  };

  Tools.array_unique = function(array) {
    var i, unique, _i, _ref;
    unique = [];
    for (i = _i = 1, _ref = array.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      if (unique.indexOf(array[i]) === -1) {
        unique.push(array[i]);
      }
    }
    return unique;
  };

  Tools.promiseWhile = function(condition, body) {
    var done, _loop;
    done = Q.defer();
    _loop = function() {
      if (!condition()) {
        return done.resolve();
      }
      return Q.when(body(), _loop, done.reject);
    };
    Q.nextTick(_loop);
    return done.promise;
  };

  return Tools;

})();

module.exports = Tools;
