
/*
 * This file is part of the Konsserto package.
 *
 * (c) Jessym Reziga <jessym@konsserto.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var Filesystem, Tools, filesystem, path_helper;

filesystem = use('fs');

path_helper = use('path');

Tools = use('@Konsserto/Component/Static/Tools');

Filesystem = (function() {
  function Filesystem() {}

  Filesystem.traceOutput = function(object) {
    var out, root;
    out = object.replace(/\\/g, '/');
    root = process.cwd();
    root = root.replace(/\\/g, '/');
    out = out.replace(root, '');
    return out;
  };

  Filesystem.mktree = function(root, tree, chmod, verbose) {
    var content, dir, e, index, name, _i, _len;
    if (chmod == null) {
      chmod = 755;
    }
    if (verbose == null) {
      verbose = true;
    }
    if (tree.constructor.name === 'Array') {
      for (index = _i = 0, _len = tree.length; _i < _len; index = ++_i) {
        dir = tree[index];
        root += dir + '/';
        if (verbose) {
          console.info('Generated directory : [' + this.traceOutput(root) + ']');
        }
        try {
          filesystem.mkdirSync(root, chmod);
        } catch (_error) {
          e = _error;
          if (e.code !== 'EEXIST') {
            throw e;
          }
        }
      }
      return path_helper.normalize(root);
    } else if (tree.constructor.name === 'Object') {
      for (name in tree) {
        content = tree[name];
        if (name === ':files') {
          Filesystem.mkfiles(root, content);
        } else {
          dir = root + name + '/';
          try {
            filesystem.mkdirSync(dir, chmod);
          } catch (_error) {
            e = _error;
            if (e.code !== 'EEXIST') {
              throw e;
            }
          }
          if (verbose) {
            console.info('Generated directory : [' + this.traceOutput(dir) + ']');
          }
          if (content !== false && content !== null && content !== void 0) {
            Filesystem.mktree(dir, content);
          }
        }
      }
      return true;
    }
  };

  Filesystem.mkfiles = function(root, files) {
    var buffFile, content, e, file, _results;
    _results = [];
    for (file in files) {
      content = files[file];
      if (content.indexOf('@file:') === 0) {
        _results.push(filesystem.createReadStream(content.replace('@file:', '')).pipe(filesystem.createWriteStream(root + file)));
      } else {
        try {
          buffFile = filesystem.createWriteStream(root + file);
          buffFile.write(content);
          buffFile.close();
          _results.push(console.info('Generated file : [' + this.traceOutput(root + file) + ']'));
        } catch (_error) {
          e = _error;
          throw e;
        }
      }
    }
    return _results;
  };

  Filesystem.mkdir = function(dir, chmod, del) {
    if (del == null) {
      del = false;
    }
    if (del) {
      this.rmtree(dir);
    }
    if (!filesystem.existsSync(dir)) {
      return filesystem.mkdirSync(dir, chmod);
    }
  };

  Filesystem.rmtree = function(dir) {
    var e, filename, i, list, stat, _i, _ref;
    if (filesystem.existsSync(dir)) {
      list = filesystem.readdirSync(dir);
      for (i = _i = 0, _ref = list.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (list[i] != null) {
          filename = path.join(dir, list[i]);
          stat = filesystem.statSync(filename);
          if (filename === "." || filename === "..") {
            continue;
          } else if (stat.isDirectory()) {
            this.rmtree(filename);
          } else {
            filesystem.unlinkSync(filename);
          }
        }
      }
      try {
        return filesystem.rmdirSync(dir);
      } catch (_error) {
        e = _error;
        if (e.errno !== 53) {
          throw e;
        }
      }
    }
  };

  Filesystem.copytree = function(src, dst) {
    return this.mktree(dst + '/', this.generatetree(src));
  };

  Filesystem.generatetree = function(src, root) {
    var filename, i, list, stat, _i, _ref;
    if (root == null) {
      root = {};
    }
    if (filesystem.existsSync(src)) {
      list = filesystem.readdirSync(src);
      for (i = _i = 0, _ref = list.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (list[i] != null) {
          filename = path.join(src, list[i]);
          stat = filesystem.statSync(filename);
          if (filename === "." || filename === "..") {
            continue;
          } else if (stat.isDirectory()) {
            root[path.basename(filename)] = {};
            this.generatetree(filename, root[path.basename(filename)]);
          } else {
            if (root == null) {
              root = {};
            }
            if (root[':files'] == null) {
              root[':files'] = {};
            }
            root[':files'][path.basename(filename)] = '@file:' + filename;
          }
        }
      }
    }
    return root;
  };

  return Filesystem;

})();

module.exports = Filesystem;
